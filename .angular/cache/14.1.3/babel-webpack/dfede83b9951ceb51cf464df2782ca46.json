{"ast":null,"code":"/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { p as printIonWarning } from './index-c4b11676.js';\n/**\n * Returns true if the selected day is equal to the reference day\n */\n\nconst isSameDay = (baseParts, compareParts) => {\n  return baseParts.month === compareParts.month && baseParts.day === compareParts.day && baseParts.year === compareParts.year;\n};\n/**\n * Returns true is the selected day is before the reference day.\n */\n\n\nconst isBefore = (baseParts, compareParts) => {\n  return baseParts.year < compareParts.year || baseParts.year === compareParts.year && baseParts.month < compareParts.month || baseParts.year === compareParts.year && baseParts.month === compareParts.month && baseParts.day && baseParts.day < compareParts.day;\n};\n/**\n * Returns true is the selected day is after the reference day.\n */\n\n\nconst isAfter = (baseParts, compareParts) => {\n  return baseParts.year > compareParts.year || baseParts.year === compareParts.year && baseParts.month > compareParts.month || baseParts.year === compareParts.year && baseParts.month === compareParts.month && baseParts.day && baseParts.day > compareParts.day;\n};\n\nconst warnIfValueOutOfBounds = (value, min, max) => {\n  const valueArray = Array.isArray(value) ? value : [value];\n\n  for (const val of valueArray) {\n    if (min && isBefore(val, min) || max && isAfter(val, max)) {\n      printIonWarning('The value provided to ion-datetime is out of bounds.\\n\\n' + `Min: ${JSON.stringify(min)}\\n` + `Max: ${JSON.stringify(max)}\\n` + `Value: ${JSON.stringify(value)}`);\n      break;\n    }\n  }\n};\n/**\n * Determines if given year is a\n * leap year. Returns `true` if year\n * is a leap year. Returns `false`\n * otherwise.\n */\n\n\nconst isLeapYear = year => {\n  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;\n};\n\nconst is24Hour = (locale, hourCycle) => {\n  /**\n   * If developer has explicitly enabled h23 time\n   * then return early and do not look at the system default.\n   */\n  if (hourCycle !== undefined) {\n    return hourCycle === 'h23';\n  }\n  /**\n   * If hourCycle was not specified, check the locale\n   * that is set on the user's device. We first check the\n   * Intl.DateTimeFormat hourCycle option as developers can encode this\n   * option into the locale string. Example: `en-US-u-hc-h23`\n   */\n\n\n  const formatted = new Intl.DateTimeFormat(locale, {\n    hour: 'numeric'\n  });\n  const options = formatted.resolvedOptions();\n\n  if (options.hourCycle !== undefined) {\n    return options.hourCycle === 'h23';\n  }\n  /**\n   * If hourCycle is not specified (either through lack\n   * of browser support or locale information) then fall\n   * back to this slower hourCycle check.\n   */\n\n\n  const date = new Date('5/18/2021 00:00');\n  const parts = formatted.formatToParts(date);\n  const hour = parts.find(p => p.type === 'hour');\n\n  if (!hour) {\n    throw new Error('Hour value not found from DateTimeFormat');\n  }\n\n  return hour.value === '00';\n};\n/**\n * Given a date object, returns the number\n * of days in that month.\n * Month value begin at 1, not 0.\n * i.e. January = month 1.\n */\n\n\nconst getNumDaysInMonth = (month, year) => {\n  return month === 4 || month === 6 || month === 9 || month === 11 ? 30 : month === 2 ? isLeapYear(year) ? 29 : 28 : 31;\n};\n/**\n * Certain locales display month then year while\n * others display year then month.\n * We can use Intl.DateTimeFormat to determine\n * the ordering for each locale.\n * The formatOptions param can be used to customize\n * which pieces of a date to compare against the month\n * with. For example, some locales render dd/mm/yyyy\n * while others render mm/dd/yyyy. This function can be\n * used for variations of the same \"month first\" check.\n */\n\n\nconst isMonthFirstLocale = (locale, formatOptions = {\n  month: 'numeric',\n  year: 'numeric'\n}) => {\n  /**\n   * By setting month and year we guarantee that only\n   * month, year, and literal (slashes '/', for example)\n   * values are included in the formatToParts results.\n   *\n   * The ordering of the parts will be determined by\n   * the locale. So if the month is the first value,\n   * then we know month should be shown first. If the\n   * year is the first value, then we know year should be shown first.\n   *\n   * This ordering can be controlled by customizing the locale property.\n   */\n  const parts = new Intl.DateTimeFormat(locale, formatOptions).formatToParts(new Date());\n  return parts[0].type === 'month';\n};\n/**\n * Determines if the given locale formats the day period (am/pm) to the\n * left or right of the hour.\n * @param locale The locale to check.\n * @returns `true` if the locale formats the day period to the left of the hour.\n */\n\n\nconst isLocaleDayPeriodRTL = locale => {\n  const parts = new Intl.DateTimeFormat(locale, {\n    hour: 'numeric'\n  }).formatToParts(new Date());\n  return parts[0].type === 'dayPeriod';\n};\n\nconst twoDigit = val => {\n  return ('0' + (val !== undefined ? Math.abs(val) : '0')).slice(-2);\n};\n\nconst fourDigit = val => {\n  return ('000' + (val !== undefined ? Math.abs(val) : '0')).slice(-4);\n};\n\nfunction convertDataToISO(data) {\n  if (Array.isArray(data)) {\n    return data.map(parts => convertDataToISO(parts));\n  } // https://www.w3.org/TR/NOTE-datetime\n\n\n  let rtn = '';\n\n  if (data.year !== undefined) {\n    // YYYY\n    rtn = fourDigit(data.year);\n\n    if (data.month !== undefined) {\n      // YYYY-MM\n      rtn += '-' + twoDigit(data.month);\n\n      if (data.day !== undefined) {\n        // YYYY-MM-DD\n        rtn += '-' + twoDigit(data.day);\n\n        if (data.hour !== undefined) {\n          // YYYY-MM-DDTHH:mm:SS\n          rtn += `T${twoDigit(data.hour)}:${twoDigit(data.minute)}:00`;\n\n          if (data.tzOffset === undefined) {\n            // YYYY-MM-DDTHH:mm:SSZ\n            rtn += 'Z';\n          } else {\n            // YYYY-MM-DDTHH:mm:SS+/-HH:mm\n            rtn += (data.tzOffset > 0 ? '+' : '-') + twoDigit(Math.floor(Math.abs(data.tzOffset / 60))) + ':' + twoDigit(data.tzOffset % 60);\n          }\n        }\n      }\n    }\n  } else if (data.hour !== undefined) {\n    // HH:mm\n    rtn = twoDigit(data.hour) + ':' + twoDigit(data.minute);\n  }\n\n  return rtn;\n}\n/**\n * Converts an 12 hour value to 24 hours.\n */\n\n\nconst convert12HourTo24Hour = (hour, ampm) => {\n  if (ampm === undefined) {\n    return hour;\n  }\n  /**\n   * If AM and 12am\n   * then return 00:00.\n   * Otherwise just return\n   * the hour since it is\n   * already in 24 hour format.\n   */\n\n\n  if (ampm === 'am') {\n    if (hour === 12) {\n      return 0;\n    }\n\n    return hour;\n  }\n  /**\n   * If PM and 12pm\n   * just return 12:00\n   * since it is already\n   * in 24 hour format.\n   * Otherwise add 12 hours\n   * to the time.\n   */\n\n\n  if (hour === 12) {\n    return 12;\n  }\n\n  return hour + 12;\n};\n\nconst getStartOfWeek = refParts => {\n  const {\n    dayOfWeek\n  } = refParts;\n\n  if (dayOfWeek === null || dayOfWeek === undefined) {\n    throw new Error('No day of week provided');\n  }\n\n  return subtractDays(refParts, dayOfWeek);\n};\n\nconst getEndOfWeek = refParts => {\n  const {\n    dayOfWeek\n  } = refParts;\n\n  if (dayOfWeek === null || dayOfWeek === undefined) {\n    throw new Error('No day of week provided');\n  }\n\n  return addDays(refParts, 6 - dayOfWeek);\n};\n\nconst getNextDay = refParts => {\n  return addDays(refParts, 1);\n};\n\nconst getPreviousDay = refParts => {\n  return subtractDays(refParts, 1);\n};\n\nconst getPreviousWeek = refParts => {\n  return subtractDays(refParts, 7);\n};\n\nconst getNextWeek = refParts => {\n  return addDays(refParts, 7);\n};\n/**\n * Given datetime parts, subtract\n * numDays from the date.\n * Returns a new DatetimeParts object\n * Currently can only go backward at most 1 month.\n */\n\n\nconst subtractDays = (refParts, numDays) => {\n  const {\n    month,\n    day,\n    year\n  } = refParts;\n\n  if (day === null) {\n    throw new Error('No day provided');\n  }\n\n  const workingParts = {\n    month,\n    day,\n    year\n  };\n  workingParts.day = day - numDays;\n  /**\n   * If wrapping to previous month\n   * update days and decrement month\n   */\n\n  if (workingParts.day < 1) {\n    workingParts.month -= 1;\n  }\n  /**\n   * If moving to previous year, reset\n   * month to December and decrement year\n   */\n\n\n  if (workingParts.month < 1) {\n    workingParts.month = 12;\n    workingParts.year -= 1;\n  }\n  /**\n   * Determine how many days are in the current\n   * month\n   */\n\n\n  if (workingParts.day < 1) {\n    const daysInMonth = getNumDaysInMonth(workingParts.month, workingParts.year);\n    /**\n     * Take num days in month and add the\n     * number of underflow days. This number will\n     * be negative.\n     * Example: 1 week before Jan 2, 2021 is\n     * December 26, 2021 so:\n     * 2 - 7 = -5\n     * 31 + (-5) = 26\n     */\n\n    workingParts.day = daysInMonth + workingParts.day;\n  }\n\n  return workingParts;\n};\n/**\n * Given datetime parts, add\n * numDays to the date.\n * Returns a new DatetimeParts object\n * Currently can only go forward at most 1 month.\n */\n\n\nconst addDays = (refParts, numDays) => {\n  const {\n    month,\n    day,\n    year\n  } = refParts;\n\n  if (day === null) {\n    throw new Error('No day provided');\n  }\n\n  const workingParts = {\n    month,\n    day,\n    year\n  };\n  const daysInMonth = getNumDaysInMonth(month, year);\n  workingParts.day = day + numDays;\n  /**\n   * If wrapping to next month\n   * update days and increment month\n   */\n\n  if (workingParts.day > daysInMonth) {\n    workingParts.day -= daysInMonth;\n    workingParts.month += 1;\n  }\n  /**\n   * If moving to next year, reset\n   * month to January and increment year\n   */\n\n\n  if (workingParts.month > 12) {\n    workingParts.month = 1;\n    workingParts.year += 1;\n  }\n\n  return workingParts;\n};\n/**\n * Given DatetimeParts, generate the previous month.\n */\n\n\nconst getPreviousMonth = refParts => {\n  /**\n   * If current month is January, wrap backwards\n   *  to December of the previous year.\n   */\n  const month = refParts.month === 1 ? 12 : refParts.month - 1;\n  const year = refParts.month === 1 ? refParts.year - 1 : refParts.year;\n  const numDaysInMonth = getNumDaysInMonth(month, year);\n  const day = numDaysInMonth < refParts.day ? numDaysInMonth : refParts.day;\n  return {\n    month,\n    year,\n    day\n  };\n};\n/**\n * Given DatetimeParts, generate the next month.\n */\n\n\nconst getNextMonth = refParts => {\n  /**\n   * If current month is December, wrap forwards\n   *  to January of the next year.\n   */\n  const month = refParts.month === 12 ? 1 : refParts.month + 1;\n  const year = refParts.month === 12 ? refParts.year + 1 : refParts.year;\n  const numDaysInMonth = getNumDaysInMonth(month, year);\n  const day = numDaysInMonth < refParts.day ? numDaysInMonth : refParts.day;\n  return {\n    month,\n    year,\n    day\n  };\n};\n\nconst changeYear = (refParts, yearDelta) => {\n  const month = refParts.month;\n  const year = refParts.year + yearDelta;\n  const numDaysInMonth = getNumDaysInMonth(month, year);\n  const day = numDaysInMonth < refParts.day ? numDaysInMonth : refParts.day;\n  return {\n    month,\n    year,\n    day\n  };\n};\n/**\n * Given DatetimeParts, generate the previous year.\n */\n\n\nconst getPreviousYear = refParts => {\n  return changeYear(refParts, -1);\n};\n/**\n * Given DatetimeParts, generate the next year.\n */\n\n\nconst getNextYear = refParts => {\n  return changeYear(refParts, 1);\n};\n/**\n * If PM, then internal value should\n * be converted to 24-hr time.\n * Does not apply when public\n * values are already 24-hr time.\n */\n\n\nconst getInternalHourValue = (hour, use24Hour, ampm) => {\n  if (use24Hour) {\n    return hour;\n  }\n\n  return convert12HourTo24Hour(hour, ampm);\n};\n/**\n * Unless otherwise stated, all month values are\n * 1 indexed instead of the typical 0 index in JS Date.\n * Example:\n *   January = Month 0 when using JS Date\n *   January = Month 1 when using this datetime util\n */\n\n/**\n * Given the current datetime parts and a new AM/PM value\n * calculate what the hour should be in 24-hour time format.\n * Used when toggling the AM/PM segment since we store our hours\n * in 24-hour time format internally.\n */\n\n\nconst calculateHourFromAMPM = (currentParts, newAMPM) => {\n  const {\n    ampm: currentAMPM,\n    hour\n  } = currentParts;\n  let newHour = hour;\n  /**\n   * If going from AM --> PM, need to update the\n   *\n   */\n\n  if (currentAMPM === 'am' && newAMPM === 'pm') {\n    newHour = convert12HourTo24Hour(newHour, 'pm');\n    /**\n     * If going from PM --> AM\n     */\n  } else if (currentAMPM === 'pm' && newAMPM === 'am') {\n    newHour = Math.abs(newHour - 12);\n  }\n\n  return newHour;\n};\n\nconst getFormattedDayPeriod = dayPeriod => {\n  if (dayPeriod === undefined) {\n    return '';\n  }\n\n  return dayPeriod.toUpperCase();\n};\n\nconst getLocalizedTime = (locale, refParts, use24Hour) => {\n  if (refParts.hour === undefined || refParts.minute === undefined) {\n    return 'Invalid Time';\n  }\n\n  return new Intl.DateTimeFormat(locale, {\n    hour: 'numeric',\n    minute: 'numeric',\n    timeZone: 'UTC',\n    hour12: !use24Hour\n  }).format(new Date(convertDataToISO(Object.assign(Object.assign({}, refParts), {\n    // TODO: FW-1831 will remove the need to manually set the tzOffset to undefined\n    tzOffset: undefined\n  }))));\n};\n/**\n * Adds padding to a time value so\n * that it is always 2 digits.\n */\n\n\nconst addTimePadding = value => {\n  const valueToString = value.toString();\n\n  if (valueToString.length > 1) {\n    return valueToString;\n  }\n\n  return `0${valueToString}`;\n};\n/**\n * Formats the hour value so that it\n * is always 2 digits. Only applies\n * if using 12 hour format.\n */\n\n\nconst getFormattedHour = (hour, use24Hour) => {\n  if (!use24Hour) {\n    return hour.toString();\n  }\n\n  return addTimePadding(hour);\n};\n/**\n * Generates an aria-label to be read by screen readers\n * given a local, a date, and whether or not that date is\n * today's date.\n */\n\n\nconst generateDayAriaLabel = (locale, today, refParts) => {\n  if (refParts.day === null) {\n    return null;\n  }\n  /**\n   * MM/DD/YYYY will return midnight in the user's timezone.\n   */\n\n\n  const date = new Date(`${refParts.month}/${refParts.day}/${refParts.year} GMT+0000`);\n  const labelString = new Intl.DateTimeFormat(locale, {\n    weekday: 'long',\n    month: 'long',\n    day: 'numeric',\n    timeZone: 'UTC'\n  }).format(date);\n  /**\n   * If date is today, prepend \"Today\" so screen readers indicate\n   * that the date is today.\n   */\n\n  return today ? `Today, ${labelString}` : labelString;\n};\n/**\n * Gets the day of the week, month, and day\n * Used for the header in MD mode.\n */\n\n\nconst getMonthAndDay = (locale, refParts) => {\n  const date = new Date(`${refParts.month}/${refParts.day}/${refParts.year} GMT+0000`);\n  return new Intl.DateTimeFormat(locale, {\n    weekday: 'short',\n    month: 'short',\n    day: 'numeric',\n    timeZone: 'UTC'\n  }).format(date);\n};\n/**\n * Given a locale and a date object,\n * return a formatted string that includes\n * the month name and full year.\n * Example: May 2021\n */\n\n\nconst getMonthAndYear = (locale, refParts) => {\n  const date = new Date(`${refParts.month}/${refParts.day}/${refParts.year} GMT+0000`);\n  return new Intl.DateTimeFormat(locale, {\n    month: 'long',\n    year: 'numeric',\n    timeZone: 'UTC'\n  }).format(date);\n};\n/**\n * Given a locale and a date object,\n * return a formatted string that includes\n * the short month, numeric day, and full year.\n * Example: Apr 22, 2021\n */\n\n\nconst getMonthDayAndYear = (locale, refParts) => {\n  return getLocalizedDateTime(locale, refParts, {\n    month: 'short',\n    day: 'numeric',\n    year: 'numeric'\n  });\n};\n/**\n * Wrapper function for Intl.DateTimeFormat.\n * Allows developers to apply an allowed format to DatetimeParts.\n * This function also has built in safeguards for older browser bugs\n * with Intl.DateTimeFormat.\n */\n\n\nconst getLocalizedDateTime = (locale, refParts, options) => {\n  const timeString = !!refParts.hour && !!refParts.minute ? ` ${refParts.hour}:${refParts.minute}` : '';\n  const date = new Date(`${refParts.month}/${refParts.day}/${refParts.year}${timeString} GMT+0000`);\n  return new Intl.DateTimeFormat(locale, Object.assign(Object.assign({}, options), {\n    timeZone: 'UTC'\n  })).format(date);\n};\n/**\n * Gets a localized version of \"Today\"\n * Falls back to \"Today\" in English for\n * browsers that do not support RelativeTimeFormat.\n */\n\n\nconst getTodayLabel = locale => {\n  if ('RelativeTimeFormat' in Intl) {\n    const label = new Intl.RelativeTimeFormat(locale, {\n      numeric: 'auto'\n    }).format(0, 'day');\n    return label.charAt(0).toUpperCase() + label.slice(1);\n  } else {\n    return 'Today';\n  }\n};\n/**\n * When calling toISOString(), the browser\n * will convert the date to UTC time by either adding\n * or subtracting the time zone offset.\n * To work around this, we need to either add\n * or subtract the time zone offset to the Date\n * object prior to calling toISOString().\n * This allows us to get an ISO string\n * that is in the user's time zone.\n *\n * Example:\n * Time zone offset is 240\n * Meaning: The browser needs to add 240 minutes\n * to the Date object to get UTC time.\n * What Ionic does: We subtract 240 minutes\n * from the Date object. The browser then adds\n * 240 minutes in toISOString(). The result\n * is a time that is in the user's time zone\n * and not UTC.\n *\n * Note: Some timezones include minute adjustments\n * such as 30 or 45 minutes. This is why we use setMinutes\n * instead of setHours.\n * Example: India Standard Time\n * Timezone offset: -330 = -5.5 hours.\n *\n * List of timezones with 30 and 45 minute timezones:\n * https://www.timeanddate.com/time/time-zones-interesting.html\n */\n\n\nconst removeDateTzOffset = date => {\n  const tzOffset = date.getTimezoneOffset();\n  date.setMinutes(date.getMinutes() - tzOffset);\n  return date;\n};\n\nconst DATE_AM = removeDateTzOffset(new Date('2022T01:00'));\nconst DATE_PM = removeDateTzOffset(new Date('2022T13:00'));\n/**\n * Formats the locale's string representation of the day period (am/pm) for a given\n * ref parts day period.\n *\n * @param locale The locale to format the day period in.\n * @param value The date string, in ISO format.\n * @returns The localized day period (am/pm) representation of the given value.\n */\n\nconst getLocalizedDayPeriod = (locale, dayPeriod) => {\n  const date = dayPeriod === 'am' ? DATE_AM : DATE_PM;\n  const localizedDayPeriod = new Intl.DateTimeFormat(locale, {\n    hour: 'numeric',\n    timeZone: 'UTC'\n  }).formatToParts(date).find(part => part.type === 'dayPeriod');\n\n  if (localizedDayPeriod) {\n    return localizedDayPeriod.value;\n  }\n\n  return getFormattedDayPeriod(dayPeriod);\n};\n/**\n * Formats the datetime's value to a string, for use in the native input.\n *\n * @param value The value to format, either an ISO string or an array thereof.\n */\n\n\nconst formatValue = value => {\n  return Array.isArray(value) ? value.join(',') : value;\n};\n/**\n * Returns the current date as\n * an ISO string in the user's\n * time zone.\n */\n\n\nconst getToday = () => {\n  /**\n   * ion-datetime intentionally does not\n   * parse time zones/do automatic time zone\n   * conversion when accepting user input.\n   * However when we get today's date string,\n   * we want it formatted relative to the user's\n   * time zone.\n   *\n   * When calling toISOString(), the browser\n   * will convert the date to UTC time by either adding\n   * or subtracting the time zone offset.\n   * To work around this, we need to either add\n   * or subtract the time zone offset to the Date\n   * object prior to calling toISOString().\n   * This allows us to get an ISO string\n   * that is in the user's time zone.\n   */\n  return removeDateTzOffset(new Date()).toISOString();\n};\n\nconst minutes = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59];\nconst hour12 = [12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];\nconst hour23 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23];\n/**\n * Given a locale and a mode,\n * return an array with formatted days\n * of the week. iOS should display days\n * such as \"Mon\" or \"Tue\".\n * MD should display days such as \"M\"\n * or \"T\".\n */\n\nconst getDaysOfWeek = (locale, mode, firstDayOfWeek = 0) => {\n  /**\n   * Nov 1st, 2020 starts on a Sunday.\n   * ion-datetime assumes weeks start on Sunday,\n   * but is configurable via `firstDayOfWeek`.\n   */\n  const weekdayFormat = mode === 'ios' ? 'short' : 'narrow';\n  const intl = new Intl.DateTimeFormat(locale, {\n    weekday: weekdayFormat\n  });\n  const startDate = new Date('11/01/2020');\n  const daysOfWeek = [];\n  /**\n   * For each day of the week,\n   * get the day name.\n   */\n\n  for (let i = firstDayOfWeek; i < firstDayOfWeek + 7; i++) {\n    const currentDate = new Date(startDate);\n    currentDate.setDate(currentDate.getDate() + i);\n    daysOfWeek.push(intl.format(currentDate));\n  }\n\n  return daysOfWeek;\n};\n/**\n * Returns an array containing all of the\n * days in a month for a given year. Values are\n * aligned with a week calendar starting on\n * the firstDayOfWeek value (Sunday by default)\n * using null values.\n */\n\n\nconst getDaysOfMonth = (month, year, firstDayOfWeek) => {\n  const numDays = getNumDaysInMonth(month, year);\n  const firstOfMonth = new Date(`${month}/1/${year}`).getDay();\n  /**\n   * To get the first day of the month aligned on the correct\n   * day of the week, we need to determine how many \"filler\" days\n   * to generate. These filler days as empty/disabled buttons\n   * that fill the space of the days of the week before the first\n   * of the month.\n   *\n   * There are two cases here:\n   *\n   * 1. If firstOfMonth = 4, firstDayOfWeek = 0 then the offset\n   * is (4 - (0 + 1)) = 3. Since the offset loop goes from 0 to 3 inclusive,\n   * this will generate 4 filler days (0, 1, 2, 3), and then day of week 4 will have\n   * the first day of the month.\n   *\n   * 2. If firstOfMonth = 2, firstDayOfWeek = 4 then the offset\n   * is (6 - (4 - 2)) = 4. Since the offset loop goes from 0 to 4 inclusive,\n   * this will generate 5 filler days (0, 1, 2, 3, 4), and then day of week 5 will have\n   * the first day of the month.\n   */\n\n  const offset = firstOfMonth >= firstDayOfWeek ? firstOfMonth - (firstDayOfWeek + 1) : 6 - (firstDayOfWeek - firstOfMonth);\n  let days = [];\n\n  for (let i = 1; i <= numDays; i++) {\n    days.push({\n      day: i,\n      dayOfWeek: (offset + i) % 7\n    });\n  }\n\n  for (let i = 0; i <= offset; i++) {\n    days = [{\n      day: null,\n      dayOfWeek: null\n    }, ...days];\n  }\n\n  return days;\n};\n/**\n * Given a local, reference datetime parts and option\n * max/min bound datetime parts, calculate the acceptable\n * hour and minute values according to the bounds and locale.\n */\n\n\nconst generateTime = (refParts, hourCycle = 'h12', minParts, maxParts, hourValues, minuteValues) => {\n  const use24Hour = hourCycle === 'h23';\n  let processedHours = use24Hour ? hour23 : hour12;\n  let processedMinutes = minutes;\n  let isAMAllowed = true;\n  let isPMAllowed = true;\n\n  if (hourValues) {\n    processedHours = processedHours.filter(hour => hourValues.includes(hour));\n  }\n\n  if (minuteValues) {\n    processedMinutes = processedMinutes.filter(minute => minuteValues.includes(minute));\n  }\n\n  if (minParts) {\n    /**\n     * If ref day is the same as the\n     * minimum allowed day, filter hour/minute\n     * values according to min hour and minute.\n     */\n    if (isSameDay(refParts, minParts)) {\n      /**\n       * Users may not always set the hour/minute for\n       * min value (i.e. 2021-06-02) so we should allow\n       * all hours/minutes in that case.\n       */\n      if (minParts.hour !== undefined) {\n        processedHours = processedHours.filter(hour => {\n          const convertedHour = refParts.ampm === 'pm' ? (hour + 12) % 24 : hour;\n          return (use24Hour ? hour : convertedHour) >= minParts.hour;\n        });\n        isAMAllowed = minParts.hour < 13;\n      }\n\n      if (minParts.minute !== undefined) {\n        /**\n         * The minimum minute range should not be enforced when\n         * the hour is greater than the min hour.\n         *\n         * For example with a minimum range of 09:30, users\n         * should be able to select 10:00-10:29 and beyond.\n         */\n        let isPastMinHour = false;\n\n        if (minParts.hour !== undefined && refParts.hour !== undefined) {\n          if (refParts.hour > minParts.hour) {\n            isPastMinHour = true;\n          }\n        }\n\n        processedMinutes = processedMinutes.filter(minute => {\n          if (isPastMinHour) {\n            return true;\n          }\n\n          return minute >= minParts.minute;\n        });\n      }\n      /**\n       * If ref day is before minimum\n       * day do not render any hours/minute values\n       */\n\n    } else if (isBefore(refParts, minParts)) {\n      processedHours = [];\n      processedMinutes = [];\n      isAMAllowed = isPMAllowed = false;\n    }\n  }\n\n  if (maxParts) {\n    /**\n     * If ref day is the same as the\n     * maximum allowed day, filter hour/minute\n     * values according to max hour and minute.\n     */\n    if (isSameDay(refParts, maxParts)) {\n      /**\n       * Users may not always set the hour/minute for\n       * max value (i.e. 2021-06-02) so we should allow\n       * all hours/minutes in that case.\n       */\n      if (maxParts.hour !== undefined) {\n        processedHours = processedHours.filter(hour => {\n          const convertedHour = refParts.ampm === 'pm' ? (hour + 12) % 24 : hour;\n          return (use24Hour ? hour : convertedHour) <= maxParts.hour;\n        });\n        isPMAllowed = maxParts.hour >= 13;\n      }\n\n      if (maxParts.minute !== undefined && refParts.hour === maxParts.hour) {\n        // The available minutes should only be filtered when the hour is the same as the max hour.\n        // For example if the max hour is 10:30 and the current hour is 10:00,\n        // users should be able to select 00-30 minutes.\n        // If the current hour is 09:00, users should be able to select 00-60 minutes.\n        processedMinutes = processedMinutes.filter(minute => minute <= maxParts.minute);\n      }\n      /**\n       * If ref day is after minimum\n       * day do not render any hours/minute values\n       */\n\n    } else if (isAfter(refParts, maxParts)) {\n      processedHours = [];\n      processedMinutes = [];\n      isAMAllowed = isPMAllowed = false;\n    }\n  }\n\n  return {\n    hours: processedHours,\n    minutes: processedMinutes,\n    am: isAMAllowed,\n    pm: isPMAllowed\n  };\n};\n/**\n * Given DatetimeParts, generate the previous,\n * current, and and next months.\n */\n\n\nconst generateMonths = refParts => {\n  return [getPreviousMonth(refParts), {\n    month: refParts.month,\n    year: refParts.year,\n    day: refParts.day\n  }, getNextMonth(refParts)];\n};\n\nconst getMonthColumnData = (locale, refParts, minParts, maxParts, monthValues, formatOptions = {\n  month: 'long'\n}) => {\n  const {\n    year\n  } = refParts;\n  const months = [];\n\n  if (monthValues !== undefined) {\n    let processedMonths = monthValues;\n\n    if ((maxParts === null || maxParts === void 0 ? void 0 : maxParts.month) !== undefined) {\n      processedMonths = processedMonths.filter(month => month <= maxParts.month);\n    }\n\n    if ((minParts === null || minParts === void 0 ? void 0 : minParts.month) !== undefined) {\n      processedMonths = processedMonths.filter(month => month >= minParts.month);\n    }\n\n    processedMonths.forEach(processedMonth => {\n      const date = new Date(`${processedMonth}/1/${year} GMT+0000`);\n      const monthString = new Intl.DateTimeFormat(locale, Object.assign(Object.assign({}, formatOptions), {\n        timeZone: 'UTC'\n      })).format(date);\n      months.push({\n        text: monthString,\n        value: processedMonth\n      });\n    });\n  } else {\n    const maxMonth = maxParts && maxParts.year === year ? maxParts.month : 12;\n    const minMonth = minParts && minParts.year === year ? minParts.month : 1;\n\n    for (let i = minMonth; i <= maxMonth; i++) {\n      /**\n       *\n       * There is a bug on iOS 14 where\n       * Intl.DateTimeFormat takes into account\n       * the local timezone offset when formatting dates.\n       *\n       * Forcing the timezone to 'UTC' fixes the issue. However,\n       * we should keep this workaround as it is safer. In the event\n       * this breaks in another browser, we will not be impacted\n       * because all dates will be interpreted in UTC.\n       *\n       * Example:\n       * new Intl.DateTimeFormat('en-US', { month: 'long' }).format(new Date('Sat Apr 01 2006 00:00:00 GMT-0400 (EDT)')) // \"March\"\n       * new Intl.DateTimeFormat('en-US', { month: 'long', timeZone: 'UTC' }).format(new Date('Sat Apr 01 2006 00:00:00 GMT-0400 (EDT)')) // \"April\"\n       *\n       * In certain timezones, iOS 14 shows the wrong\n       * date for .toUTCString(). To combat this, we\n       * force all of the timezones to GMT+0000 (UTC).\n       *\n       * Example:\n       * Time Zone: Central European Standard Time\n       * new Date('1/1/1992').toUTCString() // \"Tue, 31 Dec 1991 23:00:00 GMT\"\n       * new Date('1/1/1992 GMT+0000').toUTCString() // \"Wed, 01 Jan 1992 00:00:00 GMT\"\n       */\n      const date = new Date(`${i}/1/${year} GMT+0000`);\n      const monthString = new Intl.DateTimeFormat(locale, Object.assign(Object.assign({}, formatOptions), {\n        timeZone: 'UTC'\n      })).format(date);\n      months.push({\n        text: monthString,\n        value: i\n      });\n    }\n  }\n\n  return months;\n};\n/**\n * Returns information regarding\n * selectable dates (i.e 1st, 2nd, 3rd, etc)\n * within a reference month.\n * @param locale The locale to format the date with\n * @param refParts The reference month/year to generate dates for\n * @param minParts The minimum bound on the date that can be returned\n * @param maxParts The maximum bound on the date that can be returned\n * @param dayValues The allowed date values\n * @returns Date data to be used in ion-picker-column-internal\n */\n\n\nconst getDayColumnData = (locale, refParts, minParts, maxParts, dayValues, formatOptions = {\n  day: 'numeric'\n}) => {\n  const {\n    month,\n    year\n  } = refParts;\n  const days = [];\n  /**\n   * If we have max/min bounds that in the same\n   * month/year as the refParts, we should\n   * use the define day as the max/min day.\n   * Otherwise, fallback to the max/min days in a month.\n   */\n\n  const numDaysInMonth = getNumDaysInMonth(month, year);\n  const maxDay = (maxParts === null || maxParts === void 0 ? void 0 : maxParts.day) && maxParts.year === year && maxParts.month === month ? maxParts.day : numDaysInMonth;\n  const minDay = (minParts === null || minParts === void 0 ? void 0 : minParts.day) && minParts.year === year && minParts.month === month ? minParts.day : 1;\n\n  if (dayValues !== undefined) {\n    let processedDays = dayValues;\n    processedDays = processedDays.filter(day => day >= minDay && day <= maxDay);\n    processedDays.forEach(processedDay => {\n      const date = new Date(`${month}/${processedDay}/${year} GMT+0000`);\n      const dayString = new Intl.DateTimeFormat(locale, Object.assign(Object.assign({}, formatOptions), {\n        timeZone: 'UTC'\n      })).format(date);\n      days.push({\n        text: dayString,\n        value: processedDay\n      });\n    });\n  } else {\n    for (let i = minDay; i <= maxDay; i++) {\n      const date = new Date(`${month}/${i}/${year} GMT+0000`);\n      const dayString = new Intl.DateTimeFormat(locale, Object.assign(Object.assign({}, formatOptions), {\n        timeZone: 'UTC'\n      })).format(date);\n      days.push({\n        text: dayString,\n        value: i\n      });\n    }\n  }\n\n  return days;\n};\n\nconst getYearColumnData = (refParts, minParts, maxParts, yearValues) => {\n  let processedYears = [];\n\n  if (yearValues !== undefined) {\n    processedYears = yearValues;\n\n    if ((maxParts === null || maxParts === void 0 ? void 0 : maxParts.year) !== undefined) {\n      processedYears = processedYears.filter(year => year <= maxParts.year);\n    }\n\n    if ((minParts === null || minParts === void 0 ? void 0 : minParts.year) !== undefined) {\n      processedYears = processedYears.filter(year => year >= minParts.year);\n    }\n  } else {\n    const {\n      year\n    } = refParts;\n    const maxYear = (maxParts === null || maxParts === void 0 ? void 0 : maxParts.year) || year;\n    const minYear = (minParts === null || minParts === void 0 ? void 0 : minParts.year) || year - 100;\n\n    for (let i = maxYear; i >= minYear; i--) {\n      processedYears.push(i);\n    }\n  }\n\n  return processedYears.map(year => ({\n    text: `${year}`,\n    value: year\n  }));\n};\n/**\n * Given a starting date and an upper bound,\n * this functions returns an array of all\n * month objects in that range.\n */\n\n\nconst getAllMonthsInRange = (currentParts, maxParts) => {\n  if (currentParts.month === maxParts.month && currentParts.year === maxParts.year) {\n    return [currentParts];\n  }\n\n  return [currentParts, ...getAllMonthsInRange(getNextMonth(currentParts), maxParts)];\n};\n/**\n * Creates and returns picker items\n * that represent the days in a month.\n * Example: \"Thu, Jun 2\"\n */\n\n\nconst getCombinedDateColumnData = (locale, refParts, todayParts, minParts, maxParts, dayValues, monthValues) => {\n  let items = [];\n  let parts = [];\n  /**\n   * Get all month objects from the min date\n   * to the max date. Note: Do not use getMonthColumnData\n   * as that function only generates dates within a\n   * single year.\n   */\n\n  let months = getAllMonthsInRange(minParts, maxParts);\n  /**\n   * Filter out any disallowed month values.\n   */\n\n  if (monthValues) {\n    months = months.filter(({\n      month\n    }) => monthValues.includes(month));\n  }\n  /**\n   * Get all of the days in the month.\n   * From there, generate an array where\n   * each item has the month, date, and day\n   * of work as the text.\n   */\n\n\n  months.forEach(monthObject => {\n    const referenceMonth = {\n      month: monthObject.month,\n      day: null,\n      year: refParts.year\n    };\n    const monthDays = getDayColumnData(locale, referenceMonth, minParts, maxParts, dayValues, {\n      month: 'short',\n      day: 'numeric',\n      weekday: 'short'\n    });\n    const dateParts = [];\n    const dateColumnItems = [];\n    monthDays.forEach(dayObject => {\n      const isToday = isSameDay(Object.assign(Object.assign({}, referenceMonth), {\n        day: dayObject.value\n      }), todayParts);\n      /**\n       * Today's date should read as \"Today\" (localized)\n       * not the actual date string\n       */\n\n      dateColumnItems.push({\n        text: isToday ? getTodayLabel(locale) : dayObject.text,\n        value: `${refParts.year}-${monthObject.month}-${dayObject.value}`\n      });\n      /**\n       * When selecting a date in the wheel picker\n       * we need access to the raw datetime parts data.\n       * The picker column only accepts values of\n       * type string or number, so we need to return\n       * two sets of data: A data set to be passed\n       * to the picker column, and a data set to\n       * be used to reference the raw data when\n       * updating the picker column value.\n       */\n\n      dateParts.push({\n        month: monthObject.month,\n        year: refParts.year,\n        day: dayObject.value\n      });\n    });\n    parts = [...parts, ...dateParts];\n    items = [...items, ...dateColumnItems];\n  });\n  return {\n    parts,\n    items\n  };\n};\n\nconst getTimeColumnsData = (locale, refParts, hourCycle, minParts, maxParts, allowedHourValues, allowedMinuteVaues) => {\n  const use24Hour = is24Hour(locale, hourCycle);\n  const {\n    hours,\n    minutes,\n    am,\n    pm\n  } = generateTime(refParts, use24Hour ? 'h23' : 'h12', minParts, maxParts, allowedHourValues, allowedMinuteVaues);\n  const hoursItems = hours.map(hour => {\n    return {\n      text: getFormattedHour(hour, use24Hour),\n      value: getInternalHourValue(hour, use24Hour, refParts.ampm)\n    };\n  });\n  const minutesItems = minutes.map(minute => {\n    return {\n      text: addTimePadding(minute),\n      value: minute\n    };\n  });\n  const dayPeriodItems = [];\n\n  if (am && !use24Hour) {\n    dayPeriodItems.push({\n      text: getLocalizedDayPeriod(locale, 'am'),\n      value: 'am'\n    });\n  }\n\n  if (pm && !use24Hour) {\n    dayPeriodItems.push({\n      text: getLocalizedDayPeriod(locale, 'pm'),\n      value: 'pm'\n    });\n  }\n\n  return {\n    minutesData: minutesItems,\n    hoursData: hoursItems,\n    dayPeriodData: dayPeriodItems\n  };\n};\n\nconst ISO_8601_REGEXP = // eslint-disable-next-line no-useless-escape\n/^(\\d{4}|[+\\-]\\d{6})(?:-(\\d{2})(?:-(\\d{2}))?)?(?:T(\\d{2}):(\\d{2})(?::(\\d{2})(?:\\.(\\d{3}))?)?(?:(Z)|([+\\-])(\\d{2})(?::(\\d{2}))?)?)?$/; // eslint-disable-next-line no-useless-escape\n\nconst TIME_REGEXP = /^((\\d{2}):(\\d{2})(?::(\\d{2})(?:\\.(\\d{3}))?)?(?:(Z)|([+\\-])(\\d{2})(?::(\\d{2}))?)?)?$/;\n/**\n * Use to convert a string of comma separated numbers or\n * an array of numbers, and clean up any user input\n */\n\nconst convertToArrayOfNumbers = input => {\n  if (input === undefined) {\n    return;\n  }\n\n  let processedInput = input;\n\n  if (typeof input === 'string') {\n    // convert the string to an array of strings\n    // auto remove any whitespace and [] characters\n    processedInput = input.replace(/\\[|\\]|\\s/g, '').split(',');\n  }\n\n  let values;\n\n  if (Array.isArray(processedInput)) {\n    // ensure each value is an actual number in the returned array\n    values = processedInput.map(num => parseInt(num, 10)).filter(isFinite);\n  } else {\n    values = [processedInput];\n  }\n\n  return values;\n};\n/**\n * Extracts date information\n * from a .calendar-day element\n * into DatetimeParts.\n */\n\n\nconst getPartsFromCalendarDay = el => {\n  return {\n    month: parseInt(el.getAttribute('data-month'), 10),\n    day: parseInt(el.getAttribute('data-day'), 10),\n    year: parseInt(el.getAttribute('data-year'), 10),\n    dayOfWeek: parseInt(el.getAttribute('data-day-of-week'), 10)\n  };\n};\n\nfunction parseDate(val) {\n  if (Array.isArray(val)) {\n    return val.map(valStr => parseDate(valStr));\n  } // manually parse IS0 cuz Date.parse cannot be trusted\n  // ISO 8601 format: 1994-12-15T13:47:20Z\n\n\n  let parse = null;\n\n  if (val != null && val !== '') {\n    // try parsing for just time first, HH:MM\n    parse = TIME_REGEXP.exec(val);\n\n    if (parse) {\n      // adjust the array so it fits nicely with the datetime parse\n      parse.unshift(undefined, undefined);\n      parse[2] = parse[3] = undefined;\n    } else {\n      // try parsing for full ISO datetime\n      parse = ISO_8601_REGEXP.exec(val);\n    }\n  }\n\n  if (parse === null) {\n    // wasn't able to parse the ISO datetime\n    return undefined;\n  } // ensure all the parse values exist with at least 0\n\n\n  for (let i = 1; i < 8; i++) {\n    parse[i] = parse[i] !== undefined ? parseInt(parse[i], 10) : undefined;\n  }\n\n  let tzOffset = 0;\n\n  if (parse[9] && parse[10]) {\n    // hours\n    tzOffset = parseInt(parse[10], 10) * 60;\n\n    if (parse[11]) {\n      // minutes\n      tzOffset += parseInt(parse[11], 10);\n    }\n\n    if (parse[9] === '-') {\n      // + or -\n      tzOffset *= -1;\n    }\n  } // can also get second and millisecond from parse[6] and parse[7] if needed\n\n\n  return {\n    year: parse[1],\n    month: parse[2],\n    day: parse[3],\n    hour: parse[4],\n    minute: parse[5],\n    tzOffset\n  };\n}\n\nconst clampDate = (dateParts, minParts, maxParts) => {\n  if (minParts && isBefore(dateParts, minParts)) {\n    return minParts;\n  } else if (maxParts && isAfter(dateParts, maxParts)) {\n    return maxParts;\n  }\n\n  return dateParts;\n};\n/**\n * Parses an hour and returns if the value is in the morning (am) or afternoon (pm).\n * @param hour The hour to format, should be 0-23\n * @returns `pm` if the hour is greater than or equal to 12, `am` if less than 12.\n */\n\n\nconst parseAmPm = hour => {\n  return hour >= 12 ? 'pm' : 'am';\n};\n\nexport { getMonthAndYear as A, getDaysOfMonth as B, generateMonths as C, is24Hour as D, getLocalizedTime as E, getMonthAndDay as F, formatValue as G, getNextYear as H, getPreviousYear as I, clampDate as J, parseAmPm as K, calculateHourFromAMPM as L, getLocalizedDateTime as M, getMonthDayAndYear as N, isAfter as a, isSameDay as b, getPreviousMonth as c, getNextMonth as d, getToday as e, getPartsFromCalendarDay as f, generateDayAriaLabel as g, getEndOfWeek as h, isBefore as i, getStartOfWeek as j, getPreviousDay as k, getNextDay as l, getPreviousWeek as m, getNextWeek as n, convertToArrayOfNumbers as o, parseDate as p, convertDataToISO as q, getCombinedDateColumnData as r, getMonthColumnData as s, getDayColumnData as t, getYearColumnData as u, isMonthFirstLocale as v, warnIfValueOutOfBounds as w, getTimeColumnsData as x, isLocaleDayPeriodRTL as y, getDaysOfWeek as z };","map":{"version":3,"names":["p","printIonWarning","isSameDay","baseParts","compareParts","month","day","year","isBefore","isAfter","warnIfValueOutOfBounds","value","min","max","valueArray","Array","isArray","val","JSON","stringify","isLeapYear","is24Hour","locale","hourCycle","undefined","formatted","Intl","DateTimeFormat","hour","options","resolvedOptions","date","Date","parts","formatToParts","find","type","Error","getNumDaysInMonth","isMonthFirstLocale","formatOptions","isLocaleDayPeriodRTL","twoDigit","Math","abs","slice","fourDigit","convertDataToISO","data","map","rtn","minute","tzOffset","floor","convert12HourTo24Hour","ampm","getStartOfWeek","refParts","dayOfWeek","subtractDays","getEndOfWeek","addDays","getNextDay","getPreviousDay","getPreviousWeek","getNextWeek","numDays","workingParts","daysInMonth","getPreviousMonth","numDaysInMonth","getNextMonth","changeYear","yearDelta","getPreviousYear","getNextYear","getInternalHourValue","use24Hour","calculateHourFromAMPM","currentParts","newAMPM","currentAMPM","newHour","getFormattedDayPeriod","dayPeriod","toUpperCase","getLocalizedTime","timeZone","hour12","format","Object","assign","addTimePadding","valueToString","toString","length","getFormattedHour","generateDayAriaLabel","today","labelString","weekday","getMonthAndDay","getMonthAndYear","getMonthDayAndYear","getLocalizedDateTime","timeString","getTodayLabel","label","RelativeTimeFormat","numeric","charAt","removeDateTzOffset","getTimezoneOffset","setMinutes","getMinutes","DATE_AM","DATE_PM","getLocalizedDayPeriod","localizedDayPeriod","part","formatValue","join","getToday","toISOString","minutes","hour23","getDaysOfWeek","mode","firstDayOfWeek","weekdayFormat","intl","startDate","daysOfWeek","i","currentDate","setDate","getDate","push","getDaysOfMonth","firstOfMonth","getDay","offset","days","generateTime","minParts","maxParts","hourValues","minuteValues","processedHours","processedMinutes","isAMAllowed","isPMAllowed","filter","includes","convertedHour","isPastMinHour","hours","am","pm","generateMonths","getMonthColumnData","monthValues","months","processedMonths","forEach","processedMonth","monthString","text","maxMonth","minMonth","getDayColumnData","dayValues","maxDay","minDay","processedDays","processedDay","dayString","getYearColumnData","yearValues","processedYears","maxYear","minYear","getAllMonthsInRange","getCombinedDateColumnData","todayParts","items","monthObject","referenceMonth","monthDays","dateParts","dateColumnItems","dayObject","isToday","getTimeColumnsData","allowedHourValues","allowedMinuteVaues","hoursItems","minutesItems","dayPeriodItems","minutesData","hoursData","dayPeriodData","ISO_8601_REGEXP","TIME_REGEXP","convertToArrayOfNumbers","input","processedInput","replace","split","values","num","parseInt","isFinite","getPartsFromCalendarDay","el","getAttribute","parseDate","valStr","parse","exec","unshift","clampDate","parseAmPm","A","B","C","D","E","F","G","H","I","J","K","L","M","N","a","b","c","d","e","f","g","h","j","k","l","m","n","o","q","r","s","t","u","v","w","x","y","z"],"sources":["d:/Github/wose_app/node_modules/@ionic/core/dist/esm/parse-26477881.js"],"sourcesContent":["/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { p as printIonWarning } from './index-c4b11676.js';\n\n/**\n * Returns true if the selected day is equal to the reference day\n */\nconst isSameDay = (baseParts, compareParts) => {\n  return (baseParts.month === compareParts.month && baseParts.day === compareParts.day && baseParts.year === compareParts.year);\n};\n/**\n * Returns true is the selected day is before the reference day.\n */\nconst isBefore = (baseParts, compareParts) => {\n  return (baseParts.year < compareParts.year ||\n    (baseParts.year === compareParts.year && baseParts.month < compareParts.month) ||\n    (baseParts.year === compareParts.year &&\n      baseParts.month === compareParts.month &&\n      baseParts.day &&\n      baseParts.day < compareParts.day));\n};\n/**\n * Returns true is the selected day is after the reference day.\n */\nconst isAfter = (baseParts, compareParts) => {\n  return (baseParts.year > compareParts.year ||\n    (baseParts.year === compareParts.year && baseParts.month > compareParts.month) ||\n    (baseParts.year === compareParts.year &&\n      baseParts.month === compareParts.month &&\n      baseParts.day &&\n      baseParts.day > compareParts.day));\n};\nconst warnIfValueOutOfBounds = (value, min, max) => {\n  const valueArray = Array.isArray(value) ? value : [value];\n  for (const val of valueArray) {\n    if ((min && isBefore(val, min)) || (max && isAfter(val, max))) {\n      printIonWarning('The value provided to ion-datetime is out of bounds.\\n\\n' +\n        `Min: ${JSON.stringify(min)}\\n` +\n        `Max: ${JSON.stringify(max)}\\n` +\n        `Value: ${JSON.stringify(value)}`);\n      break;\n    }\n  }\n};\n\n/**\n * Determines if given year is a\n * leap year. Returns `true` if year\n * is a leap year. Returns `false`\n * otherwise.\n */\nconst isLeapYear = (year) => {\n  return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;\n};\nconst is24Hour = (locale, hourCycle) => {\n  /**\n   * If developer has explicitly enabled h23 time\n   * then return early and do not look at the system default.\n   */\n  if (hourCycle !== undefined) {\n    return hourCycle === 'h23';\n  }\n  /**\n   * If hourCycle was not specified, check the locale\n   * that is set on the user's device. We first check the\n   * Intl.DateTimeFormat hourCycle option as developers can encode this\n   * option into the locale string. Example: `en-US-u-hc-h23`\n   */\n  const formatted = new Intl.DateTimeFormat(locale, { hour: 'numeric' });\n  const options = formatted.resolvedOptions();\n  if (options.hourCycle !== undefined) {\n    return options.hourCycle === 'h23';\n  }\n  /**\n   * If hourCycle is not specified (either through lack\n   * of browser support or locale information) then fall\n   * back to this slower hourCycle check.\n   */\n  const date = new Date('5/18/2021 00:00');\n  const parts = formatted.formatToParts(date);\n  const hour = parts.find((p) => p.type === 'hour');\n  if (!hour) {\n    throw new Error('Hour value not found from DateTimeFormat');\n  }\n  return hour.value === '00';\n};\n/**\n * Given a date object, returns the number\n * of days in that month.\n * Month value begin at 1, not 0.\n * i.e. January = month 1.\n */\nconst getNumDaysInMonth = (month, year) => {\n  return month === 4 || month === 6 || month === 9 || month === 11\n    ? 30\n    : month === 2\n      ? isLeapYear(year)\n        ? 29\n        : 28\n      : 31;\n};\n/**\n * Certain locales display month then year while\n * others display year then month.\n * We can use Intl.DateTimeFormat to determine\n * the ordering for each locale.\n * The formatOptions param can be used to customize\n * which pieces of a date to compare against the month\n * with. For example, some locales render dd/mm/yyyy\n * while others render mm/dd/yyyy. This function can be\n * used for variations of the same \"month first\" check.\n */\nconst isMonthFirstLocale = (locale, formatOptions = {\n  month: 'numeric',\n  year: 'numeric',\n}) => {\n  /**\n   * By setting month and year we guarantee that only\n   * month, year, and literal (slashes '/', for example)\n   * values are included in the formatToParts results.\n   *\n   * The ordering of the parts will be determined by\n   * the locale. So if the month is the first value,\n   * then we know month should be shown first. If the\n   * year is the first value, then we know year should be shown first.\n   *\n   * This ordering can be controlled by customizing the locale property.\n   */\n  const parts = new Intl.DateTimeFormat(locale, formatOptions).formatToParts(new Date());\n  return parts[0].type === 'month';\n};\n/**\n * Determines if the given locale formats the day period (am/pm) to the\n * left or right of the hour.\n * @param locale The locale to check.\n * @returns `true` if the locale formats the day period to the left of the hour.\n */\nconst isLocaleDayPeriodRTL = (locale) => {\n  const parts = new Intl.DateTimeFormat(locale, { hour: 'numeric' }).formatToParts(new Date());\n  return parts[0].type === 'dayPeriod';\n};\n\nconst twoDigit = (val) => {\n  return ('0' + (val !== undefined ? Math.abs(val) : '0')).slice(-2);\n};\nconst fourDigit = (val) => {\n  return ('000' + (val !== undefined ? Math.abs(val) : '0')).slice(-4);\n};\nfunction convertDataToISO(data) {\n  if (Array.isArray(data)) {\n    return data.map((parts) => convertDataToISO(parts));\n  }\n  // https://www.w3.org/TR/NOTE-datetime\n  let rtn = '';\n  if (data.year !== undefined) {\n    // YYYY\n    rtn = fourDigit(data.year);\n    if (data.month !== undefined) {\n      // YYYY-MM\n      rtn += '-' + twoDigit(data.month);\n      if (data.day !== undefined) {\n        // YYYY-MM-DD\n        rtn += '-' + twoDigit(data.day);\n        if (data.hour !== undefined) {\n          // YYYY-MM-DDTHH:mm:SS\n          rtn += `T${twoDigit(data.hour)}:${twoDigit(data.minute)}:00`;\n          if (data.tzOffset === undefined) {\n            // YYYY-MM-DDTHH:mm:SSZ\n            rtn += 'Z';\n          }\n          else {\n            // YYYY-MM-DDTHH:mm:SS+/-HH:mm\n            rtn +=\n              (data.tzOffset > 0 ? '+' : '-') +\n                twoDigit(Math.floor(Math.abs(data.tzOffset / 60))) +\n                ':' +\n                twoDigit(data.tzOffset % 60);\n          }\n        }\n      }\n    }\n  }\n  else if (data.hour !== undefined) {\n    // HH:mm\n    rtn = twoDigit(data.hour) + ':' + twoDigit(data.minute);\n  }\n  return rtn;\n}\n/**\n * Converts an 12 hour value to 24 hours.\n */\nconst convert12HourTo24Hour = (hour, ampm) => {\n  if (ampm === undefined) {\n    return hour;\n  }\n  /**\n   * If AM and 12am\n   * then return 00:00.\n   * Otherwise just return\n   * the hour since it is\n   * already in 24 hour format.\n   */\n  if (ampm === 'am') {\n    if (hour === 12) {\n      return 0;\n    }\n    return hour;\n  }\n  /**\n   * If PM and 12pm\n   * just return 12:00\n   * since it is already\n   * in 24 hour format.\n   * Otherwise add 12 hours\n   * to the time.\n   */\n  if (hour === 12) {\n    return 12;\n  }\n  return hour + 12;\n};\nconst getStartOfWeek = (refParts) => {\n  const { dayOfWeek } = refParts;\n  if (dayOfWeek === null || dayOfWeek === undefined) {\n    throw new Error('No day of week provided');\n  }\n  return subtractDays(refParts, dayOfWeek);\n};\nconst getEndOfWeek = (refParts) => {\n  const { dayOfWeek } = refParts;\n  if (dayOfWeek === null || dayOfWeek === undefined) {\n    throw new Error('No day of week provided');\n  }\n  return addDays(refParts, 6 - dayOfWeek);\n};\nconst getNextDay = (refParts) => {\n  return addDays(refParts, 1);\n};\nconst getPreviousDay = (refParts) => {\n  return subtractDays(refParts, 1);\n};\nconst getPreviousWeek = (refParts) => {\n  return subtractDays(refParts, 7);\n};\nconst getNextWeek = (refParts) => {\n  return addDays(refParts, 7);\n};\n/**\n * Given datetime parts, subtract\n * numDays from the date.\n * Returns a new DatetimeParts object\n * Currently can only go backward at most 1 month.\n */\nconst subtractDays = (refParts, numDays) => {\n  const { month, day, year } = refParts;\n  if (day === null) {\n    throw new Error('No day provided');\n  }\n  const workingParts = {\n    month,\n    day,\n    year,\n  };\n  workingParts.day = day - numDays;\n  /**\n   * If wrapping to previous month\n   * update days and decrement month\n   */\n  if (workingParts.day < 1) {\n    workingParts.month -= 1;\n  }\n  /**\n   * If moving to previous year, reset\n   * month to December and decrement year\n   */\n  if (workingParts.month < 1) {\n    workingParts.month = 12;\n    workingParts.year -= 1;\n  }\n  /**\n   * Determine how many days are in the current\n   * month\n   */\n  if (workingParts.day < 1) {\n    const daysInMonth = getNumDaysInMonth(workingParts.month, workingParts.year);\n    /**\n     * Take num days in month and add the\n     * number of underflow days. This number will\n     * be negative.\n     * Example: 1 week before Jan 2, 2021 is\n     * December 26, 2021 so:\n     * 2 - 7 = -5\n     * 31 + (-5) = 26\n     */\n    workingParts.day = daysInMonth + workingParts.day;\n  }\n  return workingParts;\n};\n/**\n * Given datetime parts, add\n * numDays to the date.\n * Returns a new DatetimeParts object\n * Currently can only go forward at most 1 month.\n */\nconst addDays = (refParts, numDays) => {\n  const { month, day, year } = refParts;\n  if (day === null) {\n    throw new Error('No day provided');\n  }\n  const workingParts = {\n    month,\n    day,\n    year,\n  };\n  const daysInMonth = getNumDaysInMonth(month, year);\n  workingParts.day = day + numDays;\n  /**\n   * If wrapping to next month\n   * update days and increment month\n   */\n  if (workingParts.day > daysInMonth) {\n    workingParts.day -= daysInMonth;\n    workingParts.month += 1;\n  }\n  /**\n   * If moving to next year, reset\n   * month to January and increment year\n   */\n  if (workingParts.month > 12) {\n    workingParts.month = 1;\n    workingParts.year += 1;\n  }\n  return workingParts;\n};\n/**\n * Given DatetimeParts, generate the previous month.\n */\nconst getPreviousMonth = (refParts) => {\n  /**\n   * If current month is January, wrap backwards\n   *  to December of the previous year.\n   */\n  const month = refParts.month === 1 ? 12 : refParts.month - 1;\n  const year = refParts.month === 1 ? refParts.year - 1 : refParts.year;\n  const numDaysInMonth = getNumDaysInMonth(month, year);\n  const day = numDaysInMonth < refParts.day ? numDaysInMonth : refParts.day;\n  return { month, year, day };\n};\n/**\n * Given DatetimeParts, generate the next month.\n */\nconst getNextMonth = (refParts) => {\n  /**\n   * If current month is December, wrap forwards\n   *  to January of the next year.\n   */\n  const month = refParts.month === 12 ? 1 : refParts.month + 1;\n  const year = refParts.month === 12 ? refParts.year + 1 : refParts.year;\n  const numDaysInMonth = getNumDaysInMonth(month, year);\n  const day = numDaysInMonth < refParts.day ? numDaysInMonth : refParts.day;\n  return { month, year, day };\n};\nconst changeYear = (refParts, yearDelta) => {\n  const month = refParts.month;\n  const year = refParts.year + yearDelta;\n  const numDaysInMonth = getNumDaysInMonth(month, year);\n  const day = numDaysInMonth < refParts.day ? numDaysInMonth : refParts.day;\n  return { month, year, day };\n};\n/**\n * Given DatetimeParts, generate the previous year.\n */\nconst getPreviousYear = (refParts) => {\n  return changeYear(refParts, -1);\n};\n/**\n * Given DatetimeParts, generate the next year.\n */\nconst getNextYear = (refParts) => {\n  return changeYear(refParts, 1);\n};\n/**\n * If PM, then internal value should\n * be converted to 24-hr time.\n * Does not apply when public\n * values are already 24-hr time.\n */\nconst getInternalHourValue = (hour, use24Hour, ampm) => {\n  if (use24Hour) {\n    return hour;\n  }\n  return convert12HourTo24Hour(hour, ampm);\n};\n/**\n * Unless otherwise stated, all month values are\n * 1 indexed instead of the typical 0 index in JS Date.\n * Example:\n *   January = Month 0 when using JS Date\n *   January = Month 1 when using this datetime util\n */\n/**\n * Given the current datetime parts and a new AM/PM value\n * calculate what the hour should be in 24-hour time format.\n * Used when toggling the AM/PM segment since we store our hours\n * in 24-hour time format internally.\n */\nconst calculateHourFromAMPM = (currentParts, newAMPM) => {\n  const { ampm: currentAMPM, hour } = currentParts;\n  let newHour = hour;\n  /**\n   * If going from AM --> PM, need to update the\n   *\n   */\n  if (currentAMPM === 'am' && newAMPM === 'pm') {\n    newHour = convert12HourTo24Hour(newHour, 'pm');\n    /**\n     * If going from PM --> AM\n     */\n  }\n  else if (currentAMPM === 'pm' && newAMPM === 'am') {\n    newHour = Math.abs(newHour - 12);\n  }\n  return newHour;\n};\n\nconst getFormattedDayPeriod = (dayPeriod) => {\n  if (dayPeriod === undefined) {\n    return '';\n  }\n  return dayPeriod.toUpperCase();\n};\nconst getLocalizedTime = (locale, refParts, use24Hour) => {\n  if (refParts.hour === undefined || refParts.minute === undefined) {\n    return 'Invalid Time';\n  }\n  return new Intl.DateTimeFormat(locale, {\n    hour: 'numeric',\n    minute: 'numeric',\n    timeZone: 'UTC',\n    hour12: !use24Hour,\n  }).format(new Date(convertDataToISO(Object.assign(Object.assign({}, refParts), { \n    // TODO: FW-1831 will remove the need to manually set the tzOffset to undefined\n    tzOffset: undefined }))));\n};\n/**\n * Adds padding to a time value so\n * that it is always 2 digits.\n */\nconst addTimePadding = (value) => {\n  const valueToString = value.toString();\n  if (valueToString.length > 1) {\n    return valueToString;\n  }\n  return `0${valueToString}`;\n};\n/**\n * Formats the hour value so that it\n * is always 2 digits. Only applies\n * if using 12 hour format.\n */\nconst getFormattedHour = (hour, use24Hour) => {\n  if (!use24Hour) {\n    return hour.toString();\n  }\n  return addTimePadding(hour);\n};\n/**\n * Generates an aria-label to be read by screen readers\n * given a local, a date, and whether or not that date is\n * today's date.\n */\nconst generateDayAriaLabel = (locale, today, refParts) => {\n  if (refParts.day === null) {\n    return null;\n  }\n  /**\n   * MM/DD/YYYY will return midnight in the user's timezone.\n   */\n  const date = new Date(`${refParts.month}/${refParts.day}/${refParts.year} GMT+0000`);\n  const labelString = new Intl.DateTimeFormat(locale, {\n    weekday: 'long',\n    month: 'long',\n    day: 'numeric',\n    timeZone: 'UTC',\n  }).format(date);\n  /**\n   * If date is today, prepend \"Today\" so screen readers indicate\n   * that the date is today.\n   */\n  return today ? `Today, ${labelString}` : labelString;\n};\n/**\n * Gets the day of the week, month, and day\n * Used for the header in MD mode.\n */\nconst getMonthAndDay = (locale, refParts) => {\n  const date = new Date(`${refParts.month}/${refParts.day}/${refParts.year} GMT+0000`);\n  return new Intl.DateTimeFormat(locale, { weekday: 'short', month: 'short', day: 'numeric', timeZone: 'UTC' }).format(date);\n};\n/**\n * Given a locale and a date object,\n * return a formatted string that includes\n * the month name and full year.\n * Example: May 2021\n */\nconst getMonthAndYear = (locale, refParts) => {\n  const date = new Date(`${refParts.month}/${refParts.day}/${refParts.year} GMT+0000`);\n  return new Intl.DateTimeFormat(locale, { month: 'long', year: 'numeric', timeZone: 'UTC' }).format(date);\n};\n/**\n * Given a locale and a date object,\n * return a formatted string that includes\n * the short month, numeric day, and full year.\n * Example: Apr 22, 2021\n */\nconst getMonthDayAndYear = (locale, refParts) => {\n  return getLocalizedDateTime(locale, refParts, { month: 'short', day: 'numeric', year: 'numeric' });\n};\n/**\n * Wrapper function for Intl.DateTimeFormat.\n * Allows developers to apply an allowed format to DatetimeParts.\n * This function also has built in safeguards for older browser bugs\n * with Intl.DateTimeFormat.\n */\nconst getLocalizedDateTime = (locale, refParts, options) => {\n  const timeString = !!refParts.hour && !!refParts.minute ? ` ${refParts.hour}:${refParts.minute}` : '';\n  const date = new Date(`${refParts.month}/${refParts.day}/${refParts.year}${timeString} GMT+0000`);\n  return new Intl.DateTimeFormat(locale, Object.assign(Object.assign({}, options), { timeZone: 'UTC' })).format(date);\n};\n/**\n * Gets a localized version of \"Today\"\n * Falls back to \"Today\" in English for\n * browsers that do not support RelativeTimeFormat.\n */\nconst getTodayLabel = (locale) => {\n  if ('RelativeTimeFormat' in Intl) {\n    const label = new Intl.RelativeTimeFormat(locale, { numeric: 'auto' }).format(0, 'day');\n    return label.charAt(0).toUpperCase() + label.slice(1);\n  }\n  else {\n    return 'Today';\n  }\n};\n/**\n * When calling toISOString(), the browser\n * will convert the date to UTC time by either adding\n * or subtracting the time zone offset.\n * To work around this, we need to either add\n * or subtract the time zone offset to the Date\n * object prior to calling toISOString().\n * This allows us to get an ISO string\n * that is in the user's time zone.\n *\n * Example:\n * Time zone offset is 240\n * Meaning: The browser needs to add 240 minutes\n * to the Date object to get UTC time.\n * What Ionic does: We subtract 240 minutes\n * from the Date object. The browser then adds\n * 240 minutes in toISOString(). The result\n * is a time that is in the user's time zone\n * and not UTC.\n *\n * Note: Some timezones include minute adjustments\n * such as 30 or 45 minutes. This is why we use setMinutes\n * instead of setHours.\n * Example: India Standard Time\n * Timezone offset: -330 = -5.5 hours.\n *\n * List of timezones with 30 and 45 minute timezones:\n * https://www.timeanddate.com/time/time-zones-interesting.html\n */\nconst removeDateTzOffset = (date) => {\n  const tzOffset = date.getTimezoneOffset();\n  date.setMinutes(date.getMinutes() - tzOffset);\n  return date;\n};\nconst DATE_AM = removeDateTzOffset(new Date('2022T01:00'));\nconst DATE_PM = removeDateTzOffset(new Date('2022T13:00'));\n/**\n * Formats the locale's string representation of the day period (am/pm) for a given\n * ref parts day period.\n *\n * @param locale The locale to format the day period in.\n * @param value The date string, in ISO format.\n * @returns The localized day period (am/pm) representation of the given value.\n */\nconst getLocalizedDayPeriod = (locale, dayPeriod) => {\n  const date = dayPeriod === 'am' ? DATE_AM : DATE_PM;\n  const localizedDayPeriod = new Intl.DateTimeFormat(locale, {\n    hour: 'numeric',\n    timeZone: 'UTC',\n  })\n    .formatToParts(date)\n    .find((part) => part.type === 'dayPeriod');\n  if (localizedDayPeriod) {\n    return localizedDayPeriod.value;\n  }\n  return getFormattedDayPeriod(dayPeriod);\n};\n/**\n * Formats the datetime's value to a string, for use in the native input.\n *\n * @param value The value to format, either an ISO string or an array thereof.\n */\nconst formatValue = (value) => {\n  return Array.isArray(value) ? value.join(',') : value;\n};\n\n/**\n * Returns the current date as\n * an ISO string in the user's\n * time zone.\n */\nconst getToday = () => {\n  /**\n   * ion-datetime intentionally does not\n   * parse time zones/do automatic time zone\n   * conversion when accepting user input.\n   * However when we get today's date string,\n   * we want it formatted relative to the user's\n   * time zone.\n   *\n   * When calling toISOString(), the browser\n   * will convert the date to UTC time by either adding\n   * or subtracting the time zone offset.\n   * To work around this, we need to either add\n   * or subtract the time zone offset to the Date\n   * object prior to calling toISOString().\n   * This allows us to get an ISO string\n   * that is in the user's time zone.\n   */\n  return removeDateTzOffset(new Date()).toISOString();\n};\nconst minutes = [\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,\n  32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n];\nconst hour12 = [12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];\nconst hour23 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23];\n/**\n * Given a locale and a mode,\n * return an array with formatted days\n * of the week. iOS should display days\n * such as \"Mon\" or \"Tue\".\n * MD should display days such as \"M\"\n * or \"T\".\n */\nconst getDaysOfWeek = (locale, mode, firstDayOfWeek = 0) => {\n  /**\n   * Nov 1st, 2020 starts on a Sunday.\n   * ion-datetime assumes weeks start on Sunday,\n   * but is configurable via `firstDayOfWeek`.\n   */\n  const weekdayFormat = mode === 'ios' ? 'short' : 'narrow';\n  const intl = new Intl.DateTimeFormat(locale, { weekday: weekdayFormat });\n  const startDate = new Date('11/01/2020');\n  const daysOfWeek = [];\n  /**\n   * For each day of the week,\n   * get the day name.\n   */\n  for (let i = firstDayOfWeek; i < firstDayOfWeek + 7; i++) {\n    const currentDate = new Date(startDate);\n    currentDate.setDate(currentDate.getDate() + i);\n    daysOfWeek.push(intl.format(currentDate));\n  }\n  return daysOfWeek;\n};\n/**\n * Returns an array containing all of the\n * days in a month for a given year. Values are\n * aligned with a week calendar starting on\n * the firstDayOfWeek value (Sunday by default)\n * using null values.\n */\nconst getDaysOfMonth = (month, year, firstDayOfWeek) => {\n  const numDays = getNumDaysInMonth(month, year);\n  const firstOfMonth = new Date(`${month}/1/${year}`).getDay();\n  /**\n   * To get the first day of the month aligned on the correct\n   * day of the week, we need to determine how many \"filler\" days\n   * to generate. These filler days as empty/disabled buttons\n   * that fill the space of the days of the week before the first\n   * of the month.\n   *\n   * There are two cases here:\n   *\n   * 1. If firstOfMonth = 4, firstDayOfWeek = 0 then the offset\n   * is (4 - (0 + 1)) = 3. Since the offset loop goes from 0 to 3 inclusive,\n   * this will generate 4 filler days (0, 1, 2, 3), and then day of week 4 will have\n   * the first day of the month.\n   *\n   * 2. If firstOfMonth = 2, firstDayOfWeek = 4 then the offset\n   * is (6 - (4 - 2)) = 4. Since the offset loop goes from 0 to 4 inclusive,\n   * this will generate 5 filler days (0, 1, 2, 3, 4), and then day of week 5 will have\n   * the first day of the month.\n   */\n  const offset = firstOfMonth >= firstDayOfWeek ? firstOfMonth - (firstDayOfWeek + 1) : 6 - (firstDayOfWeek - firstOfMonth);\n  let days = [];\n  for (let i = 1; i <= numDays; i++) {\n    days.push({ day: i, dayOfWeek: (offset + i) % 7 });\n  }\n  for (let i = 0; i <= offset; i++) {\n    days = [{ day: null, dayOfWeek: null }, ...days];\n  }\n  return days;\n};\n/**\n * Given a local, reference datetime parts and option\n * max/min bound datetime parts, calculate the acceptable\n * hour and minute values according to the bounds and locale.\n */\nconst generateTime = (refParts, hourCycle = 'h12', minParts, maxParts, hourValues, minuteValues) => {\n  const use24Hour = hourCycle === 'h23';\n  let processedHours = use24Hour ? hour23 : hour12;\n  let processedMinutes = minutes;\n  let isAMAllowed = true;\n  let isPMAllowed = true;\n  if (hourValues) {\n    processedHours = processedHours.filter((hour) => hourValues.includes(hour));\n  }\n  if (minuteValues) {\n    processedMinutes = processedMinutes.filter((minute) => minuteValues.includes(minute));\n  }\n  if (minParts) {\n    /**\n     * If ref day is the same as the\n     * minimum allowed day, filter hour/minute\n     * values according to min hour and minute.\n     */\n    if (isSameDay(refParts, minParts)) {\n      /**\n       * Users may not always set the hour/minute for\n       * min value (i.e. 2021-06-02) so we should allow\n       * all hours/minutes in that case.\n       */\n      if (minParts.hour !== undefined) {\n        processedHours = processedHours.filter((hour) => {\n          const convertedHour = refParts.ampm === 'pm' ? (hour + 12) % 24 : hour;\n          return (use24Hour ? hour : convertedHour) >= minParts.hour;\n        });\n        isAMAllowed = minParts.hour < 13;\n      }\n      if (minParts.minute !== undefined) {\n        /**\n         * The minimum minute range should not be enforced when\n         * the hour is greater than the min hour.\n         *\n         * For example with a minimum range of 09:30, users\n         * should be able to select 10:00-10:29 and beyond.\n         */\n        let isPastMinHour = false;\n        if (minParts.hour !== undefined && refParts.hour !== undefined) {\n          if (refParts.hour > minParts.hour) {\n            isPastMinHour = true;\n          }\n        }\n        processedMinutes = processedMinutes.filter((minute) => {\n          if (isPastMinHour) {\n            return true;\n          }\n          return minute >= minParts.minute;\n        });\n      }\n      /**\n       * If ref day is before minimum\n       * day do not render any hours/minute values\n       */\n    }\n    else if (isBefore(refParts, minParts)) {\n      processedHours = [];\n      processedMinutes = [];\n      isAMAllowed = isPMAllowed = false;\n    }\n  }\n  if (maxParts) {\n    /**\n     * If ref day is the same as the\n     * maximum allowed day, filter hour/minute\n     * values according to max hour and minute.\n     */\n    if (isSameDay(refParts, maxParts)) {\n      /**\n       * Users may not always set the hour/minute for\n       * max value (i.e. 2021-06-02) so we should allow\n       * all hours/minutes in that case.\n       */\n      if (maxParts.hour !== undefined) {\n        processedHours = processedHours.filter((hour) => {\n          const convertedHour = refParts.ampm === 'pm' ? (hour + 12) % 24 : hour;\n          return (use24Hour ? hour : convertedHour) <= maxParts.hour;\n        });\n        isPMAllowed = maxParts.hour >= 13;\n      }\n      if (maxParts.minute !== undefined && refParts.hour === maxParts.hour) {\n        // The available minutes should only be filtered when the hour is the same as the max hour.\n        // For example if the max hour is 10:30 and the current hour is 10:00,\n        // users should be able to select 00-30 minutes.\n        // If the current hour is 09:00, users should be able to select 00-60 minutes.\n        processedMinutes = processedMinutes.filter((minute) => minute <= maxParts.minute);\n      }\n      /**\n       * If ref day is after minimum\n       * day do not render any hours/minute values\n       */\n    }\n    else if (isAfter(refParts, maxParts)) {\n      processedHours = [];\n      processedMinutes = [];\n      isAMAllowed = isPMAllowed = false;\n    }\n  }\n  return {\n    hours: processedHours,\n    minutes: processedMinutes,\n    am: isAMAllowed,\n    pm: isPMAllowed,\n  };\n};\n/**\n * Given DatetimeParts, generate the previous,\n * current, and and next months.\n */\nconst generateMonths = (refParts) => {\n  return [\n    getPreviousMonth(refParts),\n    { month: refParts.month, year: refParts.year, day: refParts.day },\n    getNextMonth(refParts),\n  ];\n};\nconst getMonthColumnData = (locale, refParts, minParts, maxParts, monthValues, formatOptions = {\n  month: 'long',\n}) => {\n  const { year } = refParts;\n  const months = [];\n  if (monthValues !== undefined) {\n    let processedMonths = monthValues;\n    if ((maxParts === null || maxParts === void 0 ? void 0 : maxParts.month) !== undefined) {\n      processedMonths = processedMonths.filter((month) => month <= maxParts.month);\n    }\n    if ((minParts === null || minParts === void 0 ? void 0 : minParts.month) !== undefined) {\n      processedMonths = processedMonths.filter((month) => month >= minParts.month);\n    }\n    processedMonths.forEach((processedMonth) => {\n      const date = new Date(`${processedMonth}/1/${year} GMT+0000`);\n      const monthString = new Intl.DateTimeFormat(locale, Object.assign(Object.assign({}, formatOptions), { timeZone: 'UTC' })).format(date);\n      months.push({ text: monthString, value: processedMonth });\n    });\n  }\n  else {\n    const maxMonth = maxParts && maxParts.year === year ? maxParts.month : 12;\n    const minMonth = minParts && minParts.year === year ? minParts.month : 1;\n    for (let i = minMonth; i <= maxMonth; i++) {\n      /**\n       *\n       * There is a bug on iOS 14 where\n       * Intl.DateTimeFormat takes into account\n       * the local timezone offset when formatting dates.\n       *\n       * Forcing the timezone to 'UTC' fixes the issue. However,\n       * we should keep this workaround as it is safer. In the event\n       * this breaks in another browser, we will not be impacted\n       * because all dates will be interpreted in UTC.\n       *\n       * Example:\n       * new Intl.DateTimeFormat('en-US', { month: 'long' }).format(new Date('Sat Apr 01 2006 00:00:00 GMT-0400 (EDT)')) // \"March\"\n       * new Intl.DateTimeFormat('en-US', { month: 'long', timeZone: 'UTC' }).format(new Date('Sat Apr 01 2006 00:00:00 GMT-0400 (EDT)')) // \"April\"\n       *\n       * In certain timezones, iOS 14 shows the wrong\n       * date for .toUTCString(). To combat this, we\n       * force all of the timezones to GMT+0000 (UTC).\n       *\n       * Example:\n       * Time Zone: Central European Standard Time\n       * new Date('1/1/1992').toUTCString() // \"Tue, 31 Dec 1991 23:00:00 GMT\"\n       * new Date('1/1/1992 GMT+0000').toUTCString() // \"Wed, 01 Jan 1992 00:00:00 GMT\"\n       */\n      const date = new Date(`${i}/1/${year} GMT+0000`);\n      const monthString = new Intl.DateTimeFormat(locale, Object.assign(Object.assign({}, formatOptions), { timeZone: 'UTC' })).format(date);\n      months.push({ text: monthString, value: i });\n    }\n  }\n  return months;\n};\n/**\n * Returns information regarding\n * selectable dates (i.e 1st, 2nd, 3rd, etc)\n * within a reference month.\n * @param locale The locale to format the date with\n * @param refParts The reference month/year to generate dates for\n * @param minParts The minimum bound on the date that can be returned\n * @param maxParts The maximum bound on the date that can be returned\n * @param dayValues The allowed date values\n * @returns Date data to be used in ion-picker-column-internal\n */\nconst getDayColumnData = (locale, refParts, minParts, maxParts, dayValues, formatOptions = {\n  day: 'numeric',\n}) => {\n  const { month, year } = refParts;\n  const days = [];\n  /**\n   * If we have max/min bounds that in the same\n   * month/year as the refParts, we should\n   * use the define day as the max/min day.\n   * Otherwise, fallback to the max/min days in a month.\n   */\n  const numDaysInMonth = getNumDaysInMonth(month, year);\n  const maxDay = (maxParts === null || maxParts === void 0 ? void 0 : maxParts.day) && maxParts.year === year && maxParts.month === month ? maxParts.day : numDaysInMonth;\n  const minDay = (minParts === null || minParts === void 0 ? void 0 : minParts.day) && minParts.year === year && minParts.month === month ? minParts.day : 1;\n  if (dayValues !== undefined) {\n    let processedDays = dayValues;\n    processedDays = processedDays.filter((day) => day >= minDay && day <= maxDay);\n    processedDays.forEach((processedDay) => {\n      const date = new Date(`${month}/${processedDay}/${year} GMT+0000`);\n      const dayString = new Intl.DateTimeFormat(locale, Object.assign(Object.assign({}, formatOptions), { timeZone: 'UTC' })).format(date);\n      days.push({ text: dayString, value: processedDay });\n    });\n  }\n  else {\n    for (let i = minDay; i <= maxDay; i++) {\n      const date = new Date(`${month}/${i}/${year} GMT+0000`);\n      const dayString = new Intl.DateTimeFormat(locale, Object.assign(Object.assign({}, formatOptions), { timeZone: 'UTC' })).format(date);\n      days.push({ text: dayString, value: i });\n    }\n  }\n  return days;\n};\nconst getYearColumnData = (refParts, minParts, maxParts, yearValues) => {\n  let processedYears = [];\n  if (yearValues !== undefined) {\n    processedYears = yearValues;\n    if ((maxParts === null || maxParts === void 0 ? void 0 : maxParts.year) !== undefined) {\n      processedYears = processedYears.filter((year) => year <= maxParts.year);\n    }\n    if ((minParts === null || minParts === void 0 ? void 0 : minParts.year) !== undefined) {\n      processedYears = processedYears.filter((year) => year >= minParts.year);\n    }\n  }\n  else {\n    const { year } = refParts;\n    const maxYear = (maxParts === null || maxParts === void 0 ? void 0 : maxParts.year) || year;\n    const minYear = (minParts === null || minParts === void 0 ? void 0 : minParts.year) || year - 100;\n    for (let i = maxYear; i >= minYear; i--) {\n      processedYears.push(i);\n    }\n  }\n  return processedYears.map((year) => ({\n    text: `${year}`,\n    value: year,\n  }));\n};\n/**\n * Given a starting date and an upper bound,\n * this functions returns an array of all\n * month objects in that range.\n */\nconst getAllMonthsInRange = (currentParts, maxParts) => {\n  if (currentParts.month === maxParts.month && currentParts.year === maxParts.year) {\n    return [currentParts];\n  }\n  return [currentParts, ...getAllMonthsInRange(getNextMonth(currentParts), maxParts)];\n};\n/**\n * Creates and returns picker items\n * that represent the days in a month.\n * Example: \"Thu, Jun 2\"\n */\nconst getCombinedDateColumnData = (locale, refParts, todayParts, minParts, maxParts, dayValues, monthValues) => {\n  let items = [];\n  let parts = [];\n  /**\n   * Get all month objects from the min date\n   * to the max date. Note: Do not use getMonthColumnData\n   * as that function only generates dates within a\n   * single year.\n   */\n  let months = getAllMonthsInRange(minParts, maxParts);\n  /**\n   * Filter out any disallowed month values.\n   */\n  if (monthValues) {\n    months = months.filter(({ month }) => monthValues.includes(month));\n  }\n  /**\n   * Get all of the days in the month.\n   * From there, generate an array where\n   * each item has the month, date, and day\n   * of work as the text.\n   */\n  months.forEach((monthObject) => {\n    const referenceMonth = { month: monthObject.month, day: null, year: refParts.year };\n    const monthDays = getDayColumnData(locale, referenceMonth, minParts, maxParts, dayValues, {\n      month: 'short',\n      day: 'numeric',\n      weekday: 'short',\n    });\n    const dateParts = [];\n    const dateColumnItems = [];\n    monthDays.forEach((dayObject) => {\n      const isToday = isSameDay(Object.assign(Object.assign({}, referenceMonth), { day: dayObject.value }), todayParts);\n      /**\n       * Today's date should read as \"Today\" (localized)\n       * not the actual date string\n       */\n      dateColumnItems.push({\n        text: isToday ? getTodayLabel(locale) : dayObject.text,\n        value: `${refParts.year}-${monthObject.month}-${dayObject.value}`,\n      });\n      /**\n       * When selecting a date in the wheel picker\n       * we need access to the raw datetime parts data.\n       * The picker column only accepts values of\n       * type string or number, so we need to return\n       * two sets of data: A data set to be passed\n       * to the picker column, and a data set to\n       * be used to reference the raw data when\n       * updating the picker column value.\n       */\n      dateParts.push({\n        month: monthObject.month,\n        year: refParts.year,\n        day: dayObject.value,\n      });\n    });\n    parts = [...parts, ...dateParts];\n    items = [...items, ...dateColumnItems];\n  });\n  return {\n    parts,\n    items,\n  };\n};\nconst getTimeColumnsData = (locale, refParts, hourCycle, minParts, maxParts, allowedHourValues, allowedMinuteVaues) => {\n  const use24Hour = is24Hour(locale, hourCycle);\n  const { hours, minutes, am, pm } = generateTime(refParts, use24Hour ? 'h23' : 'h12', minParts, maxParts, allowedHourValues, allowedMinuteVaues);\n  const hoursItems = hours.map((hour) => {\n    return {\n      text: getFormattedHour(hour, use24Hour),\n      value: getInternalHourValue(hour, use24Hour, refParts.ampm),\n    };\n  });\n  const minutesItems = minutes.map((minute) => {\n    return {\n      text: addTimePadding(minute),\n      value: minute,\n    };\n  });\n  const dayPeriodItems = [];\n  if (am && !use24Hour) {\n    dayPeriodItems.push({\n      text: getLocalizedDayPeriod(locale, 'am'),\n      value: 'am',\n    });\n  }\n  if (pm && !use24Hour) {\n    dayPeriodItems.push({\n      text: getLocalizedDayPeriod(locale, 'pm'),\n      value: 'pm',\n    });\n  }\n  return {\n    minutesData: minutesItems,\n    hoursData: hoursItems,\n    dayPeriodData: dayPeriodItems,\n  };\n};\n\nconst ISO_8601_REGEXP = \n// eslint-disable-next-line no-useless-escape\n/^(\\d{4}|[+\\-]\\d{6})(?:-(\\d{2})(?:-(\\d{2}))?)?(?:T(\\d{2}):(\\d{2})(?::(\\d{2})(?:\\.(\\d{3}))?)?(?:(Z)|([+\\-])(\\d{2})(?::(\\d{2}))?)?)?$/;\n// eslint-disable-next-line no-useless-escape\nconst TIME_REGEXP = /^((\\d{2}):(\\d{2})(?::(\\d{2})(?:\\.(\\d{3}))?)?(?:(Z)|([+\\-])(\\d{2})(?::(\\d{2}))?)?)?$/;\n/**\n * Use to convert a string of comma separated numbers or\n * an array of numbers, and clean up any user input\n */\nconst convertToArrayOfNumbers = (input) => {\n  if (input === undefined) {\n    return;\n  }\n  let processedInput = input;\n  if (typeof input === 'string') {\n    // convert the string to an array of strings\n    // auto remove any whitespace and [] characters\n    processedInput = input.replace(/\\[|\\]|\\s/g, '').split(',');\n  }\n  let values;\n  if (Array.isArray(processedInput)) {\n    // ensure each value is an actual number in the returned array\n    values = processedInput.map((num) => parseInt(num, 10)).filter(isFinite);\n  }\n  else {\n    values = [processedInput];\n  }\n  return values;\n};\n/**\n * Extracts date information\n * from a .calendar-day element\n * into DatetimeParts.\n */\nconst getPartsFromCalendarDay = (el) => {\n  return {\n    month: parseInt(el.getAttribute('data-month'), 10),\n    day: parseInt(el.getAttribute('data-day'), 10),\n    year: parseInt(el.getAttribute('data-year'), 10),\n    dayOfWeek: parseInt(el.getAttribute('data-day-of-week'), 10),\n  };\n};\nfunction parseDate(val) {\n  if (Array.isArray(val)) {\n    return val.map((valStr) => parseDate(valStr));\n  }\n  // manually parse IS0 cuz Date.parse cannot be trusted\n  // ISO 8601 format: 1994-12-15T13:47:20Z\n  let parse = null;\n  if (val != null && val !== '') {\n    // try parsing for just time first, HH:MM\n    parse = TIME_REGEXP.exec(val);\n    if (parse) {\n      // adjust the array so it fits nicely with the datetime parse\n      parse.unshift(undefined, undefined);\n      parse[2] = parse[3] = undefined;\n    }\n    else {\n      // try parsing for full ISO datetime\n      parse = ISO_8601_REGEXP.exec(val);\n    }\n  }\n  if (parse === null) {\n    // wasn't able to parse the ISO datetime\n    return undefined;\n  }\n  // ensure all the parse values exist with at least 0\n  for (let i = 1; i < 8; i++) {\n    parse[i] = parse[i] !== undefined ? parseInt(parse[i], 10) : undefined;\n  }\n  let tzOffset = 0;\n  if (parse[9] && parse[10]) {\n    // hours\n    tzOffset = parseInt(parse[10], 10) * 60;\n    if (parse[11]) {\n      // minutes\n      tzOffset += parseInt(parse[11], 10);\n    }\n    if (parse[9] === '-') {\n      // + or -\n      tzOffset *= -1;\n    }\n  }\n  // can also get second and millisecond from parse[6] and parse[7] if needed\n  return {\n    year: parse[1],\n    month: parse[2],\n    day: parse[3],\n    hour: parse[4],\n    minute: parse[5],\n    tzOffset,\n  };\n}\nconst clampDate = (dateParts, minParts, maxParts) => {\n  if (minParts && isBefore(dateParts, minParts)) {\n    return minParts;\n  }\n  else if (maxParts && isAfter(dateParts, maxParts)) {\n    return maxParts;\n  }\n  return dateParts;\n};\n/**\n * Parses an hour and returns if the value is in the morning (am) or afternoon (pm).\n * @param hour The hour to format, should be 0-23\n * @returns `pm` if the hour is greater than or equal to 12, `am` if less than 12.\n */\nconst parseAmPm = (hour) => {\n  return hour >= 12 ? 'pm' : 'am';\n};\n\nexport { getMonthAndYear as A, getDaysOfMonth as B, generateMonths as C, is24Hour as D, getLocalizedTime as E, getMonthAndDay as F, formatValue as G, getNextYear as H, getPreviousYear as I, clampDate as J, parseAmPm as K, calculateHourFromAMPM as L, getLocalizedDateTime as M, getMonthDayAndYear as N, isAfter as a, isSameDay as b, getPreviousMonth as c, getNextMonth as d, getToday as e, getPartsFromCalendarDay as f, generateDayAriaLabel as g, getEndOfWeek as h, isBefore as i, getStartOfWeek as j, getPreviousDay as k, getNextDay as l, getPreviousWeek as m, getNextWeek as n, convertToArrayOfNumbers as o, parseDate as p, convertDataToISO as q, getCombinedDateColumnData as r, getMonthColumnData as s, getDayColumnData as t, getYearColumnData as u, isMonthFirstLocale as v, warnIfValueOutOfBounds as w, getTimeColumnsData as x, isLocaleDayPeriodRTL as y, getDaysOfWeek as z };\n"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,CAAC,IAAIC,eAAd,QAAqC,qBAArC;AAEA;AACA;AACA;;AACA,MAAMC,SAAS,GAAG,CAACC,SAAD,EAAYC,YAAZ,KAA6B;EAC7C,OAAQD,SAAS,CAACE,KAAV,KAAoBD,YAAY,CAACC,KAAjC,IAA0CF,SAAS,CAACG,GAAV,KAAkBF,YAAY,CAACE,GAAzE,IAAgFH,SAAS,CAACI,IAAV,KAAmBH,YAAY,CAACG,IAAxH;AACD,CAFD;AAGA;AACA;AACA;;;AACA,MAAMC,QAAQ,GAAG,CAACL,SAAD,EAAYC,YAAZ,KAA6B;EAC5C,OAAQD,SAAS,CAACI,IAAV,GAAiBH,YAAY,CAACG,IAA9B,IACLJ,SAAS,CAACI,IAAV,KAAmBH,YAAY,CAACG,IAAhC,IAAwCJ,SAAS,CAACE,KAAV,GAAkBD,YAAY,CAACC,KADlE,IAELF,SAAS,CAACI,IAAV,KAAmBH,YAAY,CAACG,IAAhC,IACCJ,SAAS,CAACE,KAAV,KAAoBD,YAAY,CAACC,KADlC,IAECF,SAAS,CAACG,GAFX,IAGCH,SAAS,CAACG,GAAV,GAAgBF,YAAY,CAACE,GALjC;AAMD,CAPD;AAQA;AACA;AACA;;;AACA,MAAMG,OAAO,GAAG,CAACN,SAAD,EAAYC,YAAZ,KAA6B;EAC3C,OAAQD,SAAS,CAACI,IAAV,GAAiBH,YAAY,CAACG,IAA9B,IACLJ,SAAS,CAACI,IAAV,KAAmBH,YAAY,CAACG,IAAhC,IAAwCJ,SAAS,CAACE,KAAV,GAAkBD,YAAY,CAACC,KADlE,IAELF,SAAS,CAACI,IAAV,KAAmBH,YAAY,CAACG,IAAhC,IACCJ,SAAS,CAACE,KAAV,KAAoBD,YAAY,CAACC,KADlC,IAECF,SAAS,CAACG,GAFX,IAGCH,SAAS,CAACG,GAAV,GAAgBF,YAAY,CAACE,GALjC;AAMD,CAPD;;AAQA,MAAMI,sBAAsB,GAAG,CAACC,KAAD,EAAQC,GAAR,EAAaC,GAAb,KAAqB;EAClD,MAAMC,UAAU,GAAGC,KAAK,CAACC,OAAN,CAAcL,KAAd,IAAuBA,KAAvB,GAA+B,CAACA,KAAD,CAAlD;;EACA,KAAK,MAAMM,GAAX,IAAkBH,UAAlB,EAA8B;IAC5B,IAAKF,GAAG,IAAIJ,QAAQ,CAACS,GAAD,EAAML,GAAN,CAAhB,IAAgCC,GAAG,IAAIJ,OAAO,CAACQ,GAAD,EAAMJ,GAAN,CAAlD,EAA+D;MAC7DZ,eAAe,CAAC,6DACb,QAAOiB,IAAI,CAACC,SAAL,CAAeP,GAAf,CAAoB,IADd,GAEb,QAAOM,IAAI,CAACC,SAAL,CAAeN,GAAf,CAAoB,IAFd,GAGb,UAASK,IAAI,CAACC,SAAL,CAAeR,KAAf,CAAsB,EAHnB,CAAf;MAIA;IACD;EACF;AACF,CAXD;AAaA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMS,UAAU,GAAIb,IAAD,IAAU;EAC3B,OAAQA,IAAI,GAAG,CAAP,KAAa,CAAb,IAAkBA,IAAI,GAAG,GAAP,KAAe,CAAlC,IAAwCA,IAAI,GAAG,GAAP,KAAe,CAA9D;AACD,CAFD;;AAGA,MAAMc,QAAQ,GAAG,CAACC,MAAD,EAASC,SAAT,KAAuB;EACtC;AACF;AACA;AACA;EACE,IAAIA,SAAS,KAAKC,SAAlB,EAA6B;IAC3B,OAAOD,SAAS,KAAK,KAArB;EACD;EACD;AACF;AACA;AACA;AACA;AACA;;;EACE,MAAME,SAAS,GAAG,IAAIC,IAAI,CAACC,cAAT,CAAwBL,MAAxB,EAAgC;IAAEM,IAAI,EAAE;EAAR,CAAhC,CAAlB;EACA,MAAMC,OAAO,GAAGJ,SAAS,CAACK,eAAV,EAAhB;;EACA,IAAID,OAAO,CAACN,SAAR,KAAsBC,SAA1B,EAAqC;IACnC,OAAOK,OAAO,CAACN,SAAR,KAAsB,KAA7B;EACD;EACD;AACF;AACA;AACA;AACA;;;EACE,MAAMQ,IAAI,GAAG,IAAIC,IAAJ,CAAS,iBAAT,CAAb;EACA,MAAMC,KAAK,GAAGR,SAAS,CAACS,aAAV,CAAwBH,IAAxB,CAAd;EACA,MAAMH,IAAI,GAAGK,KAAK,CAACE,IAAN,CAAYnC,CAAD,IAAOA,CAAC,CAACoC,IAAF,KAAW,MAA7B,CAAb;;EACA,IAAI,CAACR,IAAL,EAAW;IACT,MAAM,IAAIS,KAAJ,CAAU,0CAAV,CAAN;EACD;;EACD,OAAOT,IAAI,CAACjB,KAAL,KAAe,IAAtB;AACD,CA/BD;AAgCA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAM2B,iBAAiB,GAAG,CAACjC,KAAD,EAAQE,IAAR,KAAiB;EACzC,OAAOF,KAAK,KAAK,CAAV,IAAeA,KAAK,KAAK,CAAzB,IAA8BA,KAAK,KAAK,CAAxC,IAA6CA,KAAK,KAAK,EAAvD,GACH,EADG,GAEHA,KAAK,KAAK,CAAV,GACEe,UAAU,CAACb,IAAD,CAAV,GACE,EADF,GAEE,EAHJ,GAIE,EANN;AAOD,CARD;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMgC,kBAAkB,GAAG,CAACjB,MAAD,EAASkB,aAAa,GAAG;EAClDnC,KAAK,EAAE,SAD2C;EAElDE,IAAI,EAAE;AAF4C,CAAzB,KAGrB;EACJ;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAM0B,KAAK,GAAG,IAAIP,IAAI,CAACC,cAAT,CAAwBL,MAAxB,EAAgCkB,aAAhC,EAA+CN,aAA/C,CAA6D,IAAIF,IAAJ,EAA7D,CAAd;EACA,OAAOC,KAAK,CAAC,CAAD,CAAL,CAASG,IAAT,KAAkB,OAAzB;AACD,CAlBD;AAmBA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMK,oBAAoB,GAAInB,MAAD,IAAY;EACvC,MAAMW,KAAK,GAAG,IAAIP,IAAI,CAACC,cAAT,CAAwBL,MAAxB,EAAgC;IAAEM,IAAI,EAAE;EAAR,CAAhC,EAAqDM,aAArD,CAAmE,IAAIF,IAAJ,EAAnE,CAAd;EACA,OAAOC,KAAK,CAAC,CAAD,CAAL,CAASG,IAAT,KAAkB,WAAzB;AACD,CAHD;;AAKA,MAAMM,QAAQ,GAAIzB,GAAD,IAAS;EACxB,OAAO,CAAC,OAAOA,GAAG,KAAKO,SAAR,GAAoBmB,IAAI,CAACC,GAAL,CAAS3B,GAAT,CAApB,GAAoC,GAA3C,CAAD,EAAkD4B,KAAlD,CAAwD,CAAC,CAAzD,CAAP;AACD,CAFD;;AAGA,MAAMC,SAAS,GAAI7B,GAAD,IAAS;EACzB,OAAO,CAAC,SAASA,GAAG,KAAKO,SAAR,GAAoBmB,IAAI,CAACC,GAAL,CAAS3B,GAAT,CAApB,GAAoC,GAA7C,CAAD,EAAoD4B,KAApD,CAA0D,CAAC,CAA3D,CAAP;AACD,CAFD;;AAGA,SAASE,gBAAT,CAA0BC,IAA1B,EAAgC;EAC9B,IAAIjC,KAAK,CAACC,OAAN,CAAcgC,IAAd,CAAJ,EAAyB;IACvB,OAAOA,IAAI,CAACC,GAAL,CAAUhB,KAAD,IAAWc,gBAAgB,CAACd,KAAD,CAApC,CAAP;EACD,CAH6B,CAI9B;;;EACA,IAAIiB,GAAG,GAAG,EAAV;;EACA,IAAIF,IAAI,CAACzC,IAAL,KAAciB,SAAlB,EAA6B;IAC3B;IACA0B,GAAG,GAAGJ,SAAS,CAACE,IAAI,CAACzC,IAAN,CAAf;;IACA,IAAIyC,IAAI,CAAC3C,KAAL,KAAemB,SAAnB,EAA8B;MAC5B;MACA0B,GAAG,IAAI,MAAMR,QAAQ,CAACM,IAAI,CAAC3C,KAAN,CAArB;;MACA,IAAI2C,IAAI,CAAC1C,GAAL,KAAakB,SAAjB,EAA4B;QAC1B;QACA0B,GAAG,IAAI,MAAMR,QAAQ,CAACM,IAAI,CAAC1C,GAAN,CAArB;;QACA,IAAI0C,IAAI,CAACpB,IAAL,KAAcJ,SAAlB,EAA6B;UAC3B;UACA0B,GAAG,IAAK,IAAGR,QAAQ,CAACM,IAAI,CAACpB,IAAN,CAAY,IAAGc,QAAQ,CAACM,IAAI,CAACG,MAAN,CAAc,KAAxD;;UACA,IAAIH,IAAI,CAACI,QAAL,KAAkB5B,SAAtB,EAAiC;YAC/B;YACA0B,GAAG,IAAI,GAAP;UACD,CAHD,MAIK;YACH;YACAA,GAAG,IACD,CAACF,IAAI,CAACI,QAAL,GAAgB,CAAhB,GAAoB,GAApB,GAA0B,GAA3B,IACEV,QAAQ,CAACC,IAAI,CAACU,KAAL,CAAWV,IAAI,CAACC,GAAL,CAASI,IAAI,CAACI,QAAL,GAAgB,EAAzB,CAAX,CAAD,CADV,GAEE,GAFF,GAGEV,QAAQ,CAACM,IAAI,CAACI,QAAL,GAAgB,EAAjB,CAJZ;UAKD;QACF;MACF;IACF;EACF,CA3BD,MA4BK,IAAIJ,IAAI,CAACpB,IAAL,KAAcJ,SAAlB,EAA6B;IAChC;IACA0B,GAAG,GAAGR,QAAQ,CAACM,IAAI,CAACpB,IAAN,CAAR,GAAsB,GAAtB,GAA4Bc,QAAQ,CAACM,IAAI,CAACG,MAAN,CAA1C;EACD;;EACD,OAAOD,GAAP;AACD;AACD;AACA;AACA;;;AACA,MAAMI,qBAAqB,GAAG,CAAC1B,IAAD,EAAO2B,IAAP,KAAgB;EAC5C,IAAIA,IAAI,KAAK/B,SAAb,EAAwB;IACtB,OAAOI,IAAP;EACD;EACD;AACF;AACA;AACA;AACA;AACA;AACA;;;EACE,IAAI2B,IAAI,KAAK,IAAb,EAAmB;IACjB,IAAI3B,IAAI,KAAK,EAAb,EAAiB;MACf,OAAO,CAAP;IACD;;IACD,OAAOA,IAAP;EACD;EACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;EACE,IAAIA,IAAI,KAAK,EAAb,EAAiB;IACf,OAAO,EAAP;EACD;;EACD,OAAOA,IAAI,GAAG,EAAd;AACD,CA7BD;;AA8BA,MAAM4B,cAAc,GAAIC,QAAD,IAAc;EACnC,MAAM;IAAEC;EAAF,IAAgBD,QAAtB;;EACA,IAAIC,SAAS,KAAK,IAAd,IAAsBA,SAAS,KAAKlC,SAAxC,EAAmD;IACjD,MAAM,IAAIa,KAAJ,CAAU,yBAAV,CAAN;EACD;;EACD,OAAOsB,YAAY,CAACF,QAAD,EAAWC,SAAX,CAAnB;AACD,CAND;;AAOA,MAAME,YAAY,GAAIH,QAAD,IAAc;EACjC,MAAM;IAAEC;EAAF,IAAgBD,QAAtB;;EACA,IAAIC,SAAS,KAAK,IAAd,IAAsBA,SAAS,KAAKlC,SAAxC,EAAmD;IACjD,MAAM,IAAIa,KAAJ,CAAU,yBAAV,CAAN;EACD;;EACD,OAAOwB,OAAO,CAACJ,QAAD,EAAW,IAAIC,SAAf,CAAd;AACD,CAND;;AAOA,MAAMI,UAAU,GAAIL,QAAD,IAAc;EAC/B,OAAOI,OAAO,CAACJ,QAAD,EAAW,CAAX,CAAd;AACD,CAFD;;AAGA,MAAMM,cAAc,GAAIN,QAAD,IAAc;EACnC,OAAOE,YAAY,CAACF,QAAD,EAAW,CAAX,CAAnB;AACD,CAFD;;AAGA,MAAMO,eAAe,GAAIP,QAAD,IAAc;EACpC,OAAOE,YAAY,CAACF,QAAD,EAAW,CAAX,CAAnB;AACD,CAFD;;AAGA,MAAMQ,WAAW,GAAIR,QAAD,IAAc;EAChC,OAAOI,OAAO,CAACJ,QAAD,EAAW,CAAX,CAAd;AACD,CAFD;AAGA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAME,YAAY,GAAG,CAACF,QAAD,EAAWS,OAAX,KAAuB;EAC1C,MAAM;IAAE7D,KAAF;IAASC,GAAT;IAAcC;EAAd,IAAuBkD,QAA7B;;EACA,IAAInD,GAAG,KAAK,IAAZ,EAAkB;IAChB,MAAM,IAAI+B,KAAJ,CAAU,iBAAV,CAAN;EACD;;EACD,MAAM8B,YAAY,GAAG;IACnB9D,KADmB;IAEnBC,GAFmB;IAGnBC;EAHmB,CAArB;EAKA4D,YAAY,CAAC7D,GAAb,GAAmBA,GAAG,GAAG4D,OAAzB;EACA;AACF;AACA;AACA;;EACE,IAAIC,YAAY,CAAC7D,GAAb,GAAmB,CAAvB,EAA0B;IACxB6D,YAAY,CAAC9D,KAAb,IAAsB,CAAtB;EACD;EACD;AACF;AACA;AACA;;;EACE,IAAI8D,YAAY,CAAC9D,KAAb,GAAqB,CAAzB,EAA4B;IAC1B8D,YAAY,CAAC9D,KAAb,GAAqB,EAArB;IACA8D,YAAY,CAAC5D,IAAb,IAAqB,CAArB;EACD;EACD;AACF;AACA;AACA;;;EACE,IAAI4D,YAAY,CAAC7D,GAAb,GAAmB,CAAvB,EAA0B;IACxB,MAAM8D,WAAW,GAAG9B,iBAAiB,CAAC6B,YAAY,CAAC9D,KAAd,EAAqB8D,YAAY,CAAC5D,IAAlC,CAArC;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IACI4D,YAAY,CAAC7D,GAAb,GAAmB8D,WAAW,GAAGD,YAAY,CAAC7D,GAA9C;EACD;;EACD,OAAO6D,YAAP;AACD,CA5CD;AA6CA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMN,OAAO,GAAG,CAACJ,QAAD,EAAWS,OAAX,KAAuB;EACrC,MAAM;IAAE7D,KAAF;IAASC,GAAT;IAAcC;EAAd,IAAuBkD,QAA7B;;EACA,IAAInD,GAAG,KAAK,IAAZ,EAAkB;IAChB,MAAM,IAAI+B,KAAJ,CAAU,iBAAV,CAAN;EACD;;EACD,MAAM8B,YAAY,GAAG;IACnB9D,KADmB;IAEnBC,GAFmB;IAGnBC;EAHmB,CAArB;EAKA,MAAM6D,WAAW,GAAG9B,iBAAiB,CAACjC,KAAD,EAAQE,IAAR,CAArC;EACA4D,YAAY,CAAC7D,GAAb,GAAmBA,GAAG,GAAG4D,OAAzB;EACA;AACF;AACA;AACA;;EACE,IAAIC,YAAY,CAAC7D,GAAb,GAAmB8D,WAAvB,EAAoC;IAClCD,YAAY,CAAC7D,GAAb,IAAoB8D,WAApB;IACAD,YAAY,CAAC9D,KAAb,IAAsB,CAAtB;EACD;EACD;AACF;AACA;AACA;;;EACE,IAAI8D,YAAY,CAAC9D,KAAb,GAAqB,EAAzB,EAA6B;IAC3B8D,YAAY,CAAC9D,KAAb,GAAqB,CAArB;IACA8D,YAAY,CAAC5D,IAAb,IAAqB,CAArB;EACD;;EACD,OAAO4D,YAAP;AACD,CA7BD;AA8BA;AACA;AACA;;;AACA,MAAME,gBAAgB,GAAIZ,QAAD,IAAc;EACrC;AACF;AACA;AACA;EACE,MAAMpD,KAAK,GAAGoD,QAAQ,CAACpD,KAAT,KAAmB,CAAnB,GAAuB,EAAvB,GAA4BoD,QAAQ,CAACpD,KAAT,GAAiB,CAA3D;EACA,MAAME,IAAI,GAAGkD,QAAQ,CAACpD,KAAT,KAAmB,CAAnB,GAAuBoD,QAAQ,CAAClD,IAAT,GAAgB,CAAvC,GAA2CkD,QAAQ,CAAClD,IAAjE;EACA,MAAM+D,cAAc,GAAGhC,iBAAiB,CAACjC,KAAD,EAAQE,IAAR,CAAxC;EACA,MAAMD,GAAG,GAAGgE,cAAc,GAAGb,QAAQ,CAACnD,GAA1B,GAAgCgE,cAAhC,GAAiDb,QAAQ,CAACnD,GAAtE;EACA,OAAO;IAAED,KAAF;IAASE,IAAT;IAAeD;EAAf,CAAP;AACD,CAVD;AAWA;AACA;AACA;;;AACA,MAAMiE,YAAY,GAAId,QAAD,IAAc;EACjC;AACF;AACA;AACA;EACE,MAAMpD,KAAK,GAAGoD,QAAQ,CAACpD,KAAT,KAAmB,EAAnB,GAAwB,CAAxB,GAA4BoD,QAAQ,CAACpD,KAAT,GAAiB,CAA3D;EACA,MAAME,IAAI,GAAGkD,QAAQ,CAACpD,KAAT,KAAmB,EAAnB,GAAwBoD,QAAQ,CAAClD,IAAT,GAAgB,CAAxC,GAA4CkD,QAAQ,CAAClD,IAAlE;EACA,MAAM+D,cAAc,GAAGhC,iBAAiB,CAACjC,KAAD,EAAQE,IAAR,CAAxC;EACA,MAAMD,GAAG,GAAGgE,cAAc,GAAGb,QAAQ,CAACnD,GAA1B,GAAgCgE,cAAhC,GAAiDb,QAAQ,CAACnD,GAAtE;EACA,OAAO;IAAED,KAAF;IAASE,IAAT;IAAeD;EAAf,CAAP;AACD,CAVD;;AAWA,MAAMkE,UAAU,GAAG,CAACf,QAAD,EAAWgB,SAAX,KAAyB;EAC1C,MAAMpE,KAAK,GAAGoD,QAAQ,CAACpD,KAAvB;EACA,MAAME,IAAI,GAAGkD,QAAQ,CAAClD,IAAT,GAAgBkE,SAA7B;EACA,MAAMH,cAAc,GAAGhC,iBAAiB,CAACjC,KAAD,EAAQE,IAAR,CAAxC;EACA,MAAMD,GAAG,GAAGgE,cAAc,GAAGb,QAAQ,CAACnD,GAA1B,GAAgCgE,cAAhC,GAAiDb,QAAQ,CAACnD,GAAtE;EACA,OAAO;IAAED,KAAF;IAASE,IAAT;IAAeD;EAAf,CAAP;AACD,CAND;AAOA;AACA;AACA;;;AACA,MAAMoE,eAAe,GAAIjB,QAAD,IAAc;EACpC,OAAOe,UAAU,CAACf,QAAD,EAAW,CAAC,CAAZ,CAAjB;AACD,CAFD;AAGA;AACA;AACA;;;AACA,MAAMkB,WAAW,GAAIlB,QAAD,IAAc;EAChC,OAAOe,UAAU,CAACf,QAAD,EAAW,CAAX,CAAjB;AACD,CAFD;AAGA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMmB,oBAAoB,GAAG,CAAChD,IAAD,EAAOiD,SAAP,EAAkBtB,IAAlB,KAA2B;EACtD,IAAIsB,SAAJ,EAAe;IACb,OAAOjD,IAAP;EACD;;EACD,OAAO0B,qBAAqB,CAAC1B,IAAD,EAAO2B,IAAP,CAA5B;AACD,CALD;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMuB,qBAAqB,GAAG,CAACC,YAAD,EAAeC,OAAf,KAA2B;EACvD,MAAM;IAAEzB,IAAI,EAAE0B,WAAR;IAAqBrD;EAArB,IAA8BmD,YAApC;EACA,IAAIG,OAAO,GAAGtD,IAAd;EACA;AACF;AACA;AACA;;EACE,IAAIqD,WAAW,KAAK,IAAhB,IAAwBD,OAAO,KAAK,IAAxC,EAA8C;IAC5CE,OAAO,GAAG5B,qBAAqB,CAAC4B,OAAD,EAAU,IAAV,CAA/B;IACA;AACJ;AACA;EACG,CALD,MAMK,IAAID,WAAW,KAAK,IAAhB,IAAwBD,OAAO,KAAK,IAAxC,EAA8C;IACjDE,OAAO,GAAGvC,IAAI,CAACC,GAAL,CAASsC,OAAO,GAAG,EAAnB,CAAV;EACD;;EACD,OAAOA,OAAP;AACD,CAjBD;;AAmBA,MAAMC,qBAAqB,GAAIC,SAAD,IAAe;EAC3C,IAAIA,SAAS,KAAK5D,SAAlB,EAA6B;IAC3B,OAAO,EAAP;EACD;;EACD,OAAO4D,SAAS,CAACC,WAAV,EAAP;AACD,CALD;;AAMA,MAAMC,gBAAgB,GAAG,CAAChE,MAAD,EAASmC,QAAT,EAAmBoB,SAAnB,KAAiC;EACxD,IAAIpB,QAAQ,CAAC7B,IAAT,KAAkBJ,SAAlB,IAA+BiC,QAAQ,CAACN,MAAT,KAAoB3B,SAAvD,EAAkE;IAChE,OAAO,cAAP;EACD;;EACD,OAAO,IAAIE,IAAI,CAACC,cAAT,CAAwBL,MAAxB,EAAgC;IACrCM,IAAI,EAAE,SAD+B;IAErCuB,MAAM,EAAE,SAF6B;IAGrCoC,QAAQ,EAAE,KAH2B;IAIrCC,MAAM,EAAE,CAACX;EAJ4B,CAAhC,EAKJY,MALI,CAKG,IAAIzD,IAAJ,CAASe,gBAAgB,CAAC2C,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBlC,QAAlB,CAAd,EAA2C;IAC7E;IACAL,QAAQ,EAAE5B;EAFmE,CAA3C,CAAD,CAAzB,CALH,CAAP;AAQD,CAZD;AAaA;AACA;AACA;AACA;;;AACA,MAAMoE,cAAc,GAAIjF,KAAD,IAAW;EAChC,MAAMkF,aAAa,GAAGlF,KAAK,CAACmF,QAAN,EAAtB;;EACA,IAAID,aAAa,CAACE,MAAd,GAAuB,CAA3B,EAA8B;IAC5B,OAAOF,aAAP;EACD;;EACD,OAAQ,IAAGA,aAAc,EAAzB;AACD,CAND;AAOA;AACA;AACA;AACA;AACA;;;AACA,MAAMG,gBAAgB,GAAG,CAACpE,IAAD,EAAOiD,SAAP,KAAqB;EAC5C,IAAI,CAACA,SAAL,EAAgB;IACd,OAAOjD,IAAI,CAACkE,QAAL,EAAP;EACD;;EACD,OAAOF,cAAc,CAAChE,IAAD,CAArB;AACD,CALD;AAMA;AACA;AACA;AACA;AACA;;;AACA,MAAMqE,oBAAoB,GAAG,CAAC3E,MAAD,EAAS4E,KAAT,EAAgBzC,QAAhB,KAA6B;EACxD,IAAIA,QAAQ,CAACnD,GAAT,KAAiB,IAArB,EAA2B;IACzB,OAAO,IAAP;EACD;EACD;AACF;AACA;;;EACE,MAAMyB,IAAI,GAAG,IAAIC,IAAJ,CAAU,GAAEyB,QAAQ,CAACpD,KAAM,IAAGoD,QAAQ,CAACnD,GAAI,IAAGmD,QAAQ,CAAClD,IAAK,WAA5D,CAAb;EACA,MAAM4F,WAAW,GAAG,IAAIzE,IAAI,CAACC,cAAT,CAAwBL,MAAxB,EAAgC;IAClD8E,OAAO,EAAE,MADyC;IAElD/F,KAAK,EAAE,MAF2C;IAGlDC,GAAG,EAAE,SAH6C;IAIlDiF,QAAQ,EAAE;EAJwC,CAAhC,EAKjBE,MALiB,CAKV1D,IALU,CAApB;EAMA;AACF;AACA;AACA;;EACE,OAAOmE,KAAK,GAAI,UAASC,WAAY,EAAzB,GAA6BA,WAAzC;AACD,CAnBD;AAoBA;AACA;AACA;AACA;;;AACA,MAAME,cAAc,GAAG,CAAC/E,MAAD,EAASmC,QAAT,KAAsB;EAC3C,MAAM1B,IAAI,GAAG,IAAIC,IAAJ,CAAU,GAAEyB,QAAQ,CAACpD,KAAM,IAAGoD,QAAQ,CAACnD,GAAI,IAAGmD,QAAQ,CAAClD,IAAK,WAA5D,CAAb;EACA,OAAO,IAAImB,IAAI,CAACC,cAAT,CAAwBL,MAAxB,EAAgC;IAAE8E,OAAO,EAAE,OAAX;IAAoB/F,KAAK,EAAE,OAA3B;IAAoCC,GAAG,EAAE,SAAzC;IAAoDiF,QAAQ,EAAE;EAA9D,CAAhC,EAAuGE,MAAvG,CAA8G1D,IAA9G,CAAP;AACD,CAHD;AAIA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMuE,eAAe,GAAG,CAAChF,MAAD,EAASmC,QAAT,KAAsB;EAC5C,MAAM1B,IAAI,GAAG,IAAIC,IAAJ,CAAU,GAAEyB,QAAQ,CAACpD,KAAM,IAAGoD,QAAQ,CAACnD,GAAI,IAAGmD,QAAQ,CAAClD,IAAK,WAA5D,CAAb;EACA,OAAO,IAAImB,IAAI,CAACC,cAAT,CAAwBL,MAAxB,EAAgC;IAAEjB,KAAK,EAAE,MAAT;IAAiBE,IAAI,EAAE,SAAvB;IAAkCgF,QAAQ,EAAE;EAA5C,CAAhC,EAAqFE,MAArF,CAA4F1D,IAA5F,CAAP;AACD,CAHD;AAIA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMwE,kBAAkB,GAAG,CAACjF,MAAD,EAASmC,QAAT,KAAsB;EAC/C,OAAO+C,oBAAoB,CAAClF,MAAD,EAASmC,QAAT,EAAmB;IAAEpD,KAAK,EAAE,OAAT;IAAkBC,GAAG,EAAE,SAAvB;IAAkCC,IAAI,EAAE;EAAxC,CAAnB,CAA3B;AACD,CAFD;AAGA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMiG,oBAAoB,GAAG,CAAClF,MAAD,EAASmC,QAAT,EAAmB5B,OAAnB,KAA+B;EAC1D,MAAM4E,UAAU,GAAG,CAAC,CAAChD,QAAQ,CAAC7B,IAAX,IAAmB,CAAC,CAAC6B,QAAQ,CAACN,MAA9B,GAAwC,IAAGM,QAAQ,CAAC7B,IAAK,IAAG6B,QAAQ,CAACN,MAAO,EAA5E,GAAgF,EAAnG;EACA,MAAMpB,IAAI,GAAG,IAAIC,IAAJ,CAAU,GAAEyB,QAAQ,CAACpD,KAAM,IAAGoD,QAAQ,CAACnD,GAAI,IAAGmD,QAAQ,CAAClD,IAAK,GAAEkG,UAAW,WAAzE,CAAb;EACA,OAAO,IAAI/E,IAAI,CAACC,cAAT,CAAwBL,MAAxB,EAAgCoE,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB9D,OAAlB,CAAd,EAA0C;IAAE0D,QAAQ,EAAE;EAAZ,CAA1C,CAAhC,EAAgGE,MAAhG,CAAuG1D,IAAvG,CAAP;AACD,CAJD;AAKA;AACA;AACA;AACA;AACA;;;AACA,MAAM2E,aAAa,GAAIpF,MAAD,IAAY;EAChC,IAAI,wBAAwBI,IAA5B,EAAkC;IAChC,MAAMiF,KAAK,GAAG,IAAIjF,IAAI,CAACkF,kBAAT,CAA4BtF,MAA5B,EAAoC;MAAEuF,OAAO,EAAE;IAAX,CAApC,EAAyDpB,MAAzD,CAAgE,CAAhE,EAAmE,KAAnE,CAAd;IACA,OAAOkB,KAAK,CAACG,MAAN,CAAa,CAAb,EAAgBzB,WAAhB,KAAgCsB,KAAK,CAAC9D,KAAN,CAAY,CAAZ,CAAvC;EACD,CAHD,MAIK;IACH,OAAO,OAAP;EACD;AACF,CARD;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMkE,kBAAkB,GAAIhF,IAAD,IAAU;EACnC,MAAMqB,QAAQ,GAAGrB,IAAI,CAACiF,iBAAL,EAAjB;EACAjF,IAAI,CAACkF,UAAL,CAAgBlF,IAAI,CAACmF,UAAL,KAAoB9D,QAApC;EACA,OAAOrB,IAAP;AACD,CAJD;;AAKA,MAAMoF,OAAO,GAAGJ,kBAAkB,CAAC,IAAI/E,IAAJ,CAAS,YAAT,CAAD,CAAlC;AACA,MAAMoF,OAAO,GAAGL,kBAAkB,CAAC,IAAI/E,IAAJ,CAAS,YAAT,CAAD,CAAlC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMqF,qBAAqB,GAAG,CAAC/F,MAAD,EAAS8D,SAAT,KAAuB;EACnD,MAAMrD,IAAI,GAAGqD,SAAS,KAAK,IAAd,GAAqB+B,OAArB,GAA+BC,OAA5C;EACA,MAAME,kBAAkB,GAAG,IAAI5F,IAAI,CAACC,cAAT,CAAwBL,MAAxB,EAAgC;IACzDM,IAAI,EAAE,SADmD;IAEzD2D,QAAQ,EAAE;EAF+C,CAAhC,EAIxBrD,aAJwB,CAIVH,IAJU,EAKxBI,IALwB,CAKlBoF,IAAD,IAAUA,IAAI,CAACnF,IAAL,KAAc,WALL,CAA3B;;EAMA,IAAIkF,kBAAJ,EAAwB;IACtB,OAAOA,kBAAkB,CAAC3G,KAA1B;EACD;;EACD,OAAOwE,qBAAqB,CAACC,SAAD,CAA5B;AACD,CAZD;AAaA;AACA;AACA;AACA;AACA;;;AACA,MAAMoC,WAAW,GAAI7G,KAAD,IAAW;EAC7B,OAAOI,KAAK,CAACC,OAAN,CAAcL,KAAd,IAAuBA,KAAK,CAAC8G,IAAN,CAAW,GAAX,CAAvB,GAAyC9G,KAAhD;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;;;AACA,MAAM+G,QAAQ,GAAG,MAAM;EACrB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,OAAOX,kBAAkB,CAAC,IAAI/E,IAAJ,EAAD,CAAlB,CAA+B2F,WAA/B,EAAP;AACD,CAnBD;;AAoBA,MAAMC,OAAO,GAAG,CACd,CADc,EACX,CADW,EACR,CADQ,EACL,CADK,EACF,CADE,EACC,CADD,EACI,CADJ,EACO,CADP,EACU,CADV,EACa,CADb,EACgB,EADhB,EACoB,EADpB,EACwB,EADxB,EAC4B,EAD5B,EACgC,EADhC,EACoC,EADpC,EACwC,EADxC,EAC4C,EAD5C,EACgD,EADhD,EACoD,EADpD,EACwD,EADxD,EAC4D,EAD5D,EACgE,EADhE,EACoE,EADpE,EACwE,EADxE,EAC4E,EAD5E,EACgF,EADhF,EACoF,EADpF,EACwF,EADxF,EAC4F,EAD5F,EACgG,EADhG,EACoG,EADpG,EAEd,EAFc,EAEV,EAFU,EAEN,EAFM,EAEF,EAFE,EAEE,EAFF,EAEM,EAFN,EAEU,EAFV,EAEc,EAFd,EAEkB,EAFlB,EAEsB,EAFtB,EAE0B,EAF1B,EAE8B,EAF9B,EAEkC,EAFlC,EAEsC,EAFtC,EAE0C,EAF1C,EAE8C,EAF9C,EAEkD,EAFlD,EAEsD,EAFtD,EAE0D,EAF1D,EAE8D,EAF9D,EAEkE,EAFlE,EAEsE,EAFtE,EAE0E,EAF1E,EAE8E,EAF9E,EAEkF,EAFlF,EAEsF,EAFtF,EAE0F,EAF1F,EAE8F,EAF9F,CAAhB;AAIA,MAAMpC,MAAM,GAAG,CAAC,EAAD,EAAK,CAAL,EAAQ,CAAR,EAAW,CAAX,EAAc,CAAd,EAAiB,CAAjB,EAAoB,CAApB,EAAuB,CAAvB,EAA0B,CAA1B,EAA6B,CAA7B,EAAgC,EAAhC,EAAoC,EAApC,CAAf;AACA,MAAMqC,MAAM,GAAG,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,EAAgB,CAAhB,EAAmB,CAAnB,EAAsB,CAAtB,EAAyB,CAAzB,EAA4B,CAA5B,EAA+B,EAA/B,EAAmC,EAAnC,EAAuC,EAAvC,EAA2C,EAA3C,EAA+C,EAA/C,EAAmD,EAAnD,EAAuD,EAAvD,EAA2D,EAA3D,EAA+D,EAA/D,EAAmE,EAAnE,EAAuE,EAAvE,EAA2E,EAA3E,EAA+E,EAA/E,EAAmF,EAAnF,CAAf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,aAAa,GAAG,CAACxG,MAAD,EAASyG,IAAT,EAAeC,cAAc,GAAG,CAAhC,KAAsC;EAC1D;AACF;AACA;AACA;AACA;EACE,MAAMC,aAAa,GAAGF,IAAI,KAAK,KAAT,GAAiB,OAAjB,GAA2B,QAAjD;EACA,MAAMG,IAAI,GAAG,IAAIxG,IAAI,CAACC,cAAT,CAAwBL,MAAxB,EAAgC;IAAE8E,OAAO,EAAE6B;EAAX,CAAhC,CAAb;EACA,MAAME,SAAS,GAAG,IAAInG,IAAJ,CAAS,YAAT,CAAlB;EACA,MAAMoG,UAAU,GAAG,EAAnB;EACA;AACF;AACA;AACA;;EACE,KAAK,IAAIC,CAAC,GAAGL,cAAb,EAA6BK,CAAC,GAAGL,cAAc,GAAG,CAAlD,EAAqDK,CAAC,EAAtD,EAA0D;IACxD,MAAMC,WAAW,GAAG,IAAItG,IAAJ,CAASmG,SAAT,CAApB;IACAG,WAAW,CAACC,OAAZ,CAAoBD,WAAW,CAACE,OAAZ,KAAwBH,CAA5C;IACAD,UAAU,CAACK,IAAX,CAAgBP,IAAI,CAACzC,MAAL,CAAY6C,WAAZ,CAAhB;EACD;;EACD,OAAOF,UAAP;AACD,CApBD;AAqBA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMM,cAAc,GAAG,CAACrI,KAAD,EAAQE,IAAR,EAAcyH,cAAd,KAAiC;EACtD,MAAM9D,OAAO,GAAG5B,iBAAiB,CAACjC,KAAD,EAAQE,IAAR,CAAjC;EACA,MAAMoI,YAAY,GAAG,IAAI3G,IAAJ,CAAU,GAAE3B,KAAM,MAAKE,IAAK,EAA5B,EAA+BqI,MAA/B,EAArB;EACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EACE,MAAMC,MAAM,GAAGF,YAAY,IAAIX,cAAhB,GAAiCW,YAAY,IAAIX,cAAc,GAAG,CAArB,CAA7C,GAAuE,KAAKA,cAAc,GAAGW,YAAtB,CAAtF;EACA,IAAIG,IAAI,GAAG,EAAX;;EACA,KAAK,IAAIT,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAInE,OAArB,EAA8BmE,CAAC,EAA/B,EAAmC;IACjCS,IAAI,CAACL,IAAL,CAAU;MAAEnI,GAAG,EAAE+H,CAAP;MAAU3E,SAAS,EAAE,CAACmF,MAAM,GAAGR,CAAV,IAAe;IAApC,CAAV;EACD;;EACD,KAAK,IAAIA,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAIQ,MAArB,EAA6BR,CAAC,EAA9B,EAAkC;IAChCS,IAAI,GAAG,CAAC;MAAExI,GAAG,EAAE,IAAP;MAAaoD,SAAS,EAAE;IAAxB,CAAD,EAAiC,GAAGoF,IAApC,CAAP;EACD;;EACD,OAAOA,IAAP;AACD,CA/BD;AAgCA;AACA;AACA;AACA;AACA;;;AACA,MAAMC,YAAY,GAAG,CAACtF,QAAD,EAAWlC,SAAS,GAAG,KAAvB,EAA8ByH,QAA9B,EAAwCC,QAAxC,EAAkDC,UAAlD,EAA8DC,YAA9D,KAA+E;EAClG,MAAMtE,SAAS,GAAGtD,SAAS,KAAK,KAAhC;EACA,IAAI6H,cAAc,GAAGvE,SAAS,GAAGgD,MAAH,GAAYrC,MAA1C;EACA,IAAI6D,gBAAgB,GAAGzB,OAAvB;EACA,IAAI0B,WAAW,GAAG,IAAlB;EACA,IAAIC,WAAW,GAAG,IAAlB;;EACA,IAAIL,UAAJ,EAAgB;IACdE,cAAc,GAAGA,cAAc,CAACI,MAAf,CAAuB5H,IAAD,IAAUsH,UAAU,CAACO,QAAX,CAAoB7H,IAApB,CAAhC,CAAjB;EACD;;EACD,IAAIuH,YAAJ,EAAkB;IAChBE,gBAAgB,GAAGA,gBAAgB,CAACG,MAAjB,CAAyBrG,MAAD,IAAYgG,YAAY,CAACM,QAAb,CAAsBtG,MAAtB,CAApC,CAAnB;EACD;;EACD,IAAI6F,QAAJ,EAAc;IACZ;AACJ;AACA;AACA;AACA;IACI,IAAI9I,SAAS,CAACuD,QAAD,EAAWuF,QAAX,CAAb,EAAmC;MACjC;AACN;AACA;AACA;AACA;MACM,IAAIA,QAAQ,CAACpH,IAAT,KAAkBJ,SAAtB,EAAiC;QAC/B4H,cAAc,GAAGA,cAAc,CAACI,MAAf,CAAuB5H,IAAD,IAAU;UAC/C,MAAM8H,aAAa,GAAGjG,QAAQ,CAACF,IAAT,KAAkB,IAAlB,GAAyB,CAAC3B,IAAI,GAAG,EAAR,IAAc,EAAvC,GAA4CA,IAAlE;UACA,OAAO,CAACiD,SAAS,GAAGjD,IAAH,GAAU8H,aAApB,KAAsCV,QAAQ,CAACpH,IAAtD;QACD,CAHgB,CAAjB;QAIA0H,WAAW,GAAGN,QAAQ,CAACpH,IAAT,GAAgB,EAA9B;MACD;;MACD,IAAIoH,QAAQ,CAAC7F,MAAT,KAAoB3B,SAAxB,EAAmC;QACjC;AACR;AACA;AACA;AACA;AACA;AACA;QACQ,IAAImI,aAAa,GAAG,KAApB;;QACA,IAAIX,QAAQ,CAACpH,IAAT,KAAkBJ,SAAlB,IAA+BiC,QAAQ,CAAC7B,IAAT,KAAkBJ,SAArD,EAAgE;UAC9D,IAAIiC,QAAQ,CAAC7B,IAAT,GAAgBoH,QAAQ,CAACpH,IAA7B,EAAmC;YACjC+H,aAAa,GAAG,IAAhB;UACD;QACF;;QACDN,gBAAgB,GAAGA,gBAAgB,CAACG,MAAjB,CAAyBrG,MAAD,IAAY;UACrD,IAAIwG,aAAJ,EAAmB;YACjB,OAAO,IAAP;UACD;;UACD,OAAOxG,MAAM,IAAI6F,QAAQ,CAAC7F,MAA1B;QACD,CALkB,CAAnB;MAMD;MACD;AACN;AACA;AACA;;IACK,CAtCD,MAuCK,IAAI3C,QAAQ,CAACiD,QAAD,EAAWuF,QAAX,CAAZ,EAAkC;MACrCI,cAAc,GAAG,EAAjB;MACAC,gBAAgB,GAAG,EAAnB;MACAC,WAAW,GAAGC,WAAW,GAAG,KAA5B;IACD;EACF;;EACD,IAAIN,QAAJ,EAAc;IACZ;AACJ;AACA;AACA;AACA;IACI,IAAI/I,SAAS,CAACuD,QAAD,EAAWwF,QAAX,CAAb,EAAmC;MACjC;AACN;AACA;AACA;AACA;MACM,IAAIA,QAAQ,CAACrH,IAAT,KAAkBJ,SAAtB,EAAiC;QAC/B4H,cAAc,GAAGA,cAAc,CAACI,MAAf,CAAuB5H,IAAD,IAAU;UAC/C,MAAM8H,aAAa,GAAGjG,QAAQ,CAACF,IAAT,KAAkB,IAAlB,GAAyB,CAAC3B,IAAI,GAAG,EAAR,IAAc,EAAvC,GAA4CA,IAAlE;UACA,OAAO,CAACiD,SAAS,GAAGjD,IAAH,GAAU8H,aAApB,KAAsCT,QAAQ,CAACrH,IAAtD;QACD,CAHgB,CAAjB;QAIA2H,WAAW,GAAGN,QAAQ,CAACrH,IAAT,IAAiB,EAA/B;MACD;;MACD,IAAIqH,QAAQ,CAAC9F,MAAT,KAAoB3B,SAApB,IAAiCiC,QAAQ,CAAC7B,IAAT,KAAkBqH,QAAQ,CAACrH,IAAhE,EAAsE;QACpE;QACA;QACA;QACA;QACAyH,gBAAgB,GAAGA,gBAAgB,CAACG,MAAjB,CAAyBrG,MAAD,IAAYA,MAAM,IAAI8F,QAAQ,CAAC9F,MAAvD,CAAnB;MACD;MACD;AACN;AACA;AACA;;IACK,CAxBD,MAyBK,IAAI1C,OAAO,CAACgD,QAAD,EAAWwF,QAAX,CAAX,EAAiC;MACpCG,cAAc,GAAG,EAAjB;MACAC,gBAAgB,GAAG,EAAnB;MACAC,WAAW,GAAGC,WAAW,GAAG,KAA5B;IACD;EACF;;EACD,OAAO;IACLK,KAAK,EAAER,cADF;IAELxB,OAAO,EAAEyB,gBAFJ;IAGLQ,EAAE,EAAEP,WAHC;IAILQ,EAAE,EAAEP;EAJC,CAAP;AAMD,CA1GD;AA2GA;AACA;AACA;AACA;;;AACA,MAAMQ,cAAc,GAAItG,QAAD,IAAc;EACnC,OAAO,CACLY,gBAAgB,CAACZ,QAAD,CADX,EAEL;IAAEpD,KAAK,EAAEoD,QAAQ,CAACpD,KAAlB;IAAyBE,IAAI,EAAEkD,QAAQ,CAAClD,IAAxC;IAA8CD,GAAG,EAAEmD,QAAQ,CAACnD;EAA5D,CAFK,EAGLiE,YAAY,CAACd,QAAD,CAHP,CAAP;AAKD,CAND;;AAOA,MAAMuG,kBAAkB,GAAG,CAAC1I,MAAD,EAASmC,QAAT,EAAmBuF,QAAnB,EAA6BC,QAA7B,EAAuCgB,WAAvC,EAAoDzH,aAAa,GAAG;EAC7FnC,KAAK,EAAE;AADsF,CAApE,KAErB;EACJ,MAAM;IAAEE;EAAF,IAAWkD,QAAjB;EACA,MAAMyG,MAAM,GAAG,EAAf;;EACA,IAAID,WAAW,KAAKzI,SAApB,EAA+B;IAC7B,IAAI2I,eAAe,GAAGF,WAAtB;;IACA,IAAI,CAAChB,QAAQ,KAAK,IAAb,IAAqBA,QAAQ,KAAK,KAAK,CAAvC,GAA2C,KAAK,CAAhD,GAAoDA,QAAQ,CAAC5I,KAA9D,MAAyEmB,SAA7E,EAAwF;MACtF2I,eAAe,GAAGA,eAAe,CAACX,MAAhB,CAAwBnJ,KAAD,IAAWA,KAAK,IAAI4I,QAAQ,CAAC5I,KAApD,CAAlB;IACD;;IACD,IAAI,CAAC2I,QAAQ,KAAK,IAAb,IAAqBA,QAAQ,KAAK,KAAK,CAAvC,GAA2C,KAAK,CAAhD,GAAoDA,QAAQ,CAAC3I,KAA9D,MAAyEmB,SAA7E,EAAwF;MACtF2I,eAAe,GAAGA,eAAe,CAACX,MAAhB,CAAwBnJ,KAAD,IAAWA,KAAK,IAAI2I,QAAQ,CAAC3I,KAApD,CAAlB;IACD;;IACD8J,eAAe,CAACC,OAAhB,CAAyBC,cAAD,IAAoB;MAC1C,MAAMtI,IAAI,GAAG,IAAIC,IAAJ,CAAU,GAAEqI,cAAe,MAAK9J,IAAK,WAArC,CAAb;MACA,MAAM+J,WAAW,GAAG,IAAI5I,IAAI,CAACC,cAAT,CAAwBL,MAAxB,EAAgCoE,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBnD,aAAlB,CAAd,EAAgD;QAAE+C,QAAQ,EAAE;MAAZ,CAAhD,CAAhC,EAAsGE,MAAtG,CAA6G1D,IAA7G,CAApB;MACAmI,MAAM,CAACzB,IAAP,CAAY;QAAE8B,IAAI,EAAED,WAAR;QAAqB3J,KAAK,EAAE0J;MAA5B,CAAZ;IACD,CAJD;EAKD,CAbD,MAcK;IACH,MAAMG,QAAQ,GAAGvB,QAAQ,IAAIA,QAAQ,CAAC1I,IAAT,KAAkBA,IAA9B,GAAqC0I,QAAQ,CAAC5I,KAA9C,GAAsD,EAAvE;IACA,MAAMoK,QAAQ,GAAGzB,QAAQ,IAAIA,QAAQ,CAACzI,IAAT,KAAkBA,IAA9B,GAAqCyI,QAAQ,CAAC3I,KAA9C,GAAsD,CAAvE;;IACA,KAAK,IAAIgI,CAAC,GAAGoC,QAAb,EAAuBpC,CAAC,IAAImC,QAA5B,EAAsCnC,CAAC,EAAvC,EAA2C;MACzC;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACM,MAAMtG,IAAI,GAAG,IAAIC,IAAJ,CAAU,GAAEqG,CAAE,MAAK9H,IAAK,WAAxB,CAAb;MACA,MAAM+J,WAAW,GAAG,IAAI5I,IAAI,CAACC,cAAT,CAAwBL,MAAxB,EAAgCoE,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBnD,aAAlB,CAAd,EAAgD;QAAE+C,QAAQ,EAAE;MAAZ,CAAhD,CAAhC,EAAsGE,MAAtG,CAA6G1D,IAA7G,CAApB;MACAmI,MAAM,CAACzB,IAAP,CAAY;QAAE8B,IAAI,EAAED,WAAR;QAAqB3J,KAAK,EAAE0H;MAA5B,CAAZ;IACD;EACF;;EACD,OAAO6B,MAAP;AACD,CArDD;AAsDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMQ,gBAAgB,GAAG,CAACpJ,MAAD,EAASmC,QAAT,EAAmBuF,QAAnB,EAA6BC,QAA7B,EAAuC0B,SAAvC,EAAkDnI,aAAa,GAAG;EACzFlC,GAAG,EAAE;AADoF,CAAlE,KAEnB;EACJ,MAAM;IAAED,KAAF;IAASE;EAAT,IAAkBkD,QAAxB;EACA,MAAMqF,IAAI,GAAG,EAAb;EACA;AACF;AACA;AACA;AACA;AACA;;EACE,MAAMxE,cAAc,GAAGhC,iBAAiB,CAACjC,KAAD,EAAQE,IAAR,CAAxC;EACA,MAAMqK,MAAM,GAAG,CAAC3B,QAAQ,KAAK,IAAb,IAAqBA,QAAQ,KAAK,KAAK,CAAvC,GAA2C,KAAK,CAAhD,GAAoDA,QAAQ,CAAC3I,GAA9D,KAAsE2I,QAAQ,CAAC1I,IAAT,KAAkBA,IAAxF,IAAgG0I,QAAQ,CAAC5I,KAAT,KAAmBA,KAAnH,GAA2H4I,QAAQ,CAAC3I,GAApI,GAA0IgE,cAAzJ;EACA,MAAMuG,MAAM,GAAG,CAAC7B,QAAQ,KAAK,IAAb,IAAqBA,QAAQ,KAAK,KAAK,CAAvC,GAA2C,KAAK,CAAhD,GAAoDA,QAAQ,CAAC1I,GAA9D,KAAsE0I,QAAQ,CAACzI,IAAT,KAAkBA,IAAxF,IAAgGyI,QAAQ,CAAC3I,KAAT,KAAmBA,KAAnH,GAA2H2I,QAAQ,CAAC1I,GAApI,GAA0I,CAAzJ;;EACA,IAAIqK,SAAS,KAAKnJ,SAAlB,EAA6B;IAC3B,IAAIsJ,aAAa,GAAGH,SAApB;IACAG,aAAa,GAAGA,aAAa,CAACtB,MAAd,CAAsBlJ,GAAD,IAASA,GAAG,IAAIuK,MAAP,IAAiBvK,GAAG,IAAIsK,MAAtD,CAAhB;IACAE,aAAa,CAACV,OAAd,CAAuBW,YAAD,IAAkB;MACtC,MAAMhJ,IAAI,GAAG,IAAIC,IAAJ,CAAU,GAAE3B,KAAM,IAAG0K,YAAa,IAAGxK,IAAK,WAA1C,CAAb;MACA,MAAMyK,SAAS,GAAG,IAAItJ,IAAI,CAACC,cAAT,CAAwBL,MAAxB,EAAgCoE,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBnD,aAAlB,CAAd,EAAgD;QAAE+C,QAAQ,EAAE;MAAZ,CAAhD,CAAhC,EAAsGE,MAAtG,CAA6G1D,IAA7G,CAAlB;MACA+G,IAAI,CAACL,IAAL,CAAU;QAAE8B,IAAI,EAAES,SAAR;QAAmBrK,KAAK,EAAEoK;MAA1B,CAAV;IACD,CAJD;EAKD,CARD,MASK;IACH,KAAK,IAAI1C,CAAC,GAAGwC,MAAb,EAAqBxC,CAAC,IAAIuC,MAA1B,EAAkCvC,CAAC,EAAnC,EAAuC;MACrC,MAAMtG,IAAI,GAAG,IAAIC,IAAJ,CAAU,GAAE3B,KAAM,IAAGgI,CAAE,IAAG9H,IAAK,WAA/B,CAAb;MACA,MAAMyK,SAAS,GAAG,IAAItJ,IAAI,CAACC,cAAT,CAAwBL,MAAxB,EAAgCoE,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBnD,aAAlB,CAAd,EAAgD;QAAE+C,QAAQ,EAAE;MAAZ,CAAhD,CAAhC,EAAsGE,MAAtG,CAA6G1D,IAA7G,CAAlB;MACA+G,IAAI,CAACL,IAAL,CAAU;QAAE8B,IAAI,EAAES,SAAR;QAAmBrK,KAAK,EAAE0H;MAA1B,CAAV;IACD;EACF;;EACD,OAAOS,IAAP;AACD,CA/BD;;AAgCA,MAAMmC,iBAAiB,GAAG,CAACxH,QAAD,EAAWuF,QAAX,EAAqBC,QAArB,EAA+BiC,UAA/B,KAA8C;EACtE,IAAIC,cAAc,GAAG,EAArB;;EACA,IAAID,UAAU,KAAK1J,SAAnB,EAA8B;IAC5B2J,cAAc,GAAGD,UAAjB;;IACA,IAAI,CAACjC,QAAQ,KAAK,IAAb,IAAqBA,QAAQ,KAAK,KAAK,CAAvC,GAA2C,KAAK,CAAhD,GAAoDA,QAAQ,CAAC1I,IAA9D,MAAwEiB,SAA5E,EAAuF;MACrF2J,cAAc,GAAGA,cAAc,CAAC3B,MAAf,CAAuBjJ,IAAD,IAAUA,IAAI,IAAI0I,QAAQ,CAAC1I,IAAjD,CAAjB;IACD;;IACD,IAAI,CAACyI,QAAQ,KAAK,IAAb,IAAqBA,QAAQ,KAAK,KAAK,CAAvC,GAA2C,KAAK,CAAhD,GAAoDA,QAAQ,CAACzI,IAA9D,MAAwEiB,SAA5E,EAAuF;MACrF2J,cAAc,GAAGA,cAAc,CAAC3B,MAAf,CAAuBjJ,IAAD,IAAUA,IAAI,IAAIyI,QAAQ,CAACzI,IAAjD,CAAjB;IACD;EACF,CARD,MASK;IACH,MAAM;MAAEA;IAAF,IAAWkD,QAAjB;IACA,MAAM2H,OAAO,GAAG,CAACnC,QAAQ,KAAK,IAAb,IAAqBA,QAAQ,KAAK,KAAK,CAAvC,GAA2C,KAAK,CAAhD,GAAoDA,QAAQ,CAAC1I,IAA9D,KAAuEA,IAAvF;IACA,MAAM8K,OAAO,GAAG,CAACrC,QAAQ,KAAK,IAAb,IAAqBA,QAAQ,KAAK,KAAK,CAAvC,GAA2C,KAAK,CAAhD,GAAoDA,QAAQ,CAACzI,IAA9D,KAAuEA,IAAI,GAAG,GAA9F;;IACA,KAAK,IAAI8H,CAAC,GAAG+C,OAAb,EAAsB/C,CAAC,IAAIgD,OAA3B,EAAoChD,CAAC,EAArC,EAAyC;MACvC8C,cAAc,CAAC1C,IAAf,CAAoBJ,CAApB;IACD;EACF;;EACD,OAAO8C,cAAc,CAAClI,GAAf,CAAoB1C,IAAD,KAAW;IACnCgK,IAAI,EAAG,GAAEhK,IAAK,EADqB;IAEnCI,KAAK,EAAEJ;EAF4B,CAAX,CAAnB,CAAP;AAID,CAvBD;AAwBA;AACA;AACA;AACA;AACA;;;AACA,MAAM+K,mBAAmB,GAAG,CAACvG,YAAD,EAAekE,QAAf,KAA4B;EACtD,IAAIlE,YAAY,CAAC1E,KAAb,KAAuB4I,QAAQ,CAAC5I,KAAhC,IAAyC0E,YAAY,CAACxE,IAAb,KAAsB0I,QAAQ,CAAC1I,IAA5E,EAAkF;IAChF,OAAO,CAACwE,YAAD,CAAP;EACD;;EACD,OAAO,CAACA,YAAD,EAAe,GAAGuG,mBAAmB,CAAC/G,YAAY,CAACQ,YAAD,CAAb,EAA6BkE,QAA7B,CAArC,CAAP;AACD,CALD;AAMA;AACA;AACA;AACA;AACA;;;AACA,MAAMsC,yBAAyB,GAAG,CAACjK,MAAD,EAASmC,QAAT,EAAmB+H,UAAnB,EAA+BxC,QAA/B,EAAyCC,QAAzC,EAAmD0B,SAAnD,EAA8DV,WAA9D,KAA8E;EAC9G,IAAIwB,KAAK,GAAG,EAAZ;EACA,IAAIxJ,KAAK,GAAG,EAAZ;EACA;AACF;AACA;AACA;AACA;AACA;;EACE,IAAIiI,MAAM,GAAGoB,mBAAmB,CAACtC,QAAD,EAAWC,QAAX,CAAhC;EACA;AACF;AACA;;EACE,IAAIgB,WAAJ,EAAiB;IACfC,MAAM,GAAGA,MAAM,CAACV,MAAP,CAAc,CAAC;MAAEnJ;IAAF,CAAD,KAAe4J,WAAW,CAACR,QAAZ,CAAqBpJ,KAArB,CAA7B,CAAT;EACD;EACD;AACF;AACA;AACA;AACA;AACA;;;EACE6J,MAAM,CAACE,OAAP,CAAgBsB,WAAD,IAAiB;IAC9B,MAAMC,cAAc,GAAG;MAAEtL,KAAK,EAAEqL,WAAW,CAACrL,KAArB;MAA4BC,GAAG,EAAE,IAAjC;MAAuCC,IAAI,EAAEkD,QAAQ,CAAClD;IAAtD,CAAvB;IACA,MAAMqL,SAAS,GAAGlB,gBAAgB,CAACpJ,MAAD,EAASqK,cAAT,EAAyB3C,QAAzB,EAAmCC,QAAnC,EAA6C0B,SAA7C,EAAwD;MACxFtK,KAAK,EAAE,OADiF;MAExFC,GAAG,EAAE,SAFmF;MAGxF8F,OAAO,EAAE;IAH+E,CAAxD,CAAlC;IAKA,MAAMyF,SAAS,GAAG,EAAlB;IACA,MAAMC,eAAe,GAAG,EAAxB;IACAF,SAAS,CAACxB,OAAV,CAAmB2B,SAAD,IAAe;MAC/B,MAAMC,OAAO,GAAG9L,SAAS,CAACwF,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBgG,cAAlB,CAAd,EAAiD;QAAErL,GAAG,EAAEyL,SAAS,CAACpL;MAAjB,CAAjD,CAAD,EAA6E6K,UAA7E,CAAzB;MACA;AACN;AACA;AACA;;MACMM,eAAe,CAACrD,IAAhB,CAAqB;QACnB8B,IAAI,EAAEyB,OAAO,GAAGtF,aAAa,CAACpF,MAAD,CAAhB,GAA2ByK,SAAS,CAACxB,IAD/B;QAEnB5J,KAAK,EAAG,GAAE8C,QAAQ,CAAClD,IAAK,IAAGmL,WAAW,CAACrL,KAAM,IAAG0L,SAAS,CAACpL,KAAM;MAF7C,CAArB;MAIA;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;MACMkL,SAAS,CAACpD,IAAV,CAAe;QACbpI,KAAK,EAAEqL,WAAW,CAACrL,KADN;QAEbE,IAAI,EAAEkD,QAAQ,CAAClD,IAFF;QAGbD,GAAG,EAAEyL,SAAS,CAACpL;MAHF,CAAf;IAKD,CAzBD;IA0BAsB,KAAK,GAAG,CAAC,GAAGA,KAAJ,EAAW,GAAG4J,SAAd,CAAR;IACAJ,KAAK,GAAG,CAAC,GAAGA,KAAJ,EAAW,GAAGK,eAAd,CAAR;EACD,CArCD;EAsCA,OAAO;IACL7J,KADK;IAELwJ;EAFK,CAAP;AAID,CAhED;;AAiEA,MAAMQ,kBAAkB,GAAG,CAAC3K,MAAD,EAASmC,QAAT,EAAmBlC,SAAnB,EAA8ByH,QAA9B,EAAwCC,QAAxC,EAAkDiD,iBAAlD,EAAqEC,kBAArE,KAA4F;EACrH,MAAMtH,SAAS,GAAGxD,QAAQ,CAACC,MAAD,EAASC,SAAT,CAA1B;EACA,MAAM;IAAEqI,KAAF;IAAShC,OAAT;IAAkBiC,EAAlB;IAAsBC;EAAtB,IAA6Bf,YAAY,CAACtF,QAAD,EAAWoB,SAAS,GAAG,KAAH,GAAW,KAA/B,EAAsCmE,QAAtC,EAAgDC,QAAhD,EAA0DiD,iBAA1D,EAA6EC,kBAA7E,CAA/C;EACA,MAAMC,UAAU,GAAGxC,KAAK,CAAC3G,GAAN,CAAWrB,IAAD,IAAU;IACrC,OAAO;MACL2I,IAAI,EAAEvE,gBAAgB,CAACpE,IAAD,EAAOiD,SAAP,CADjB;MAELlE,KAAK,EAAEiE,oBAAoB,CAAChD,IAAD,EAAOiD,SAAP,EAAkBpB,QAAQ,CAACF,IAA3B;IAFtB,CAAP;EAID,CALkB,CAAnB;EAMA,MAAM8I,YAAY,GAAGzE,OAAO,CAAC3E,GAAR,CAAaE,MAAD,IAAY;IAC3C,OAAO;MACLoH,IAAI,EAAE3E,cAAc,CAACzC,MAAD,CADf;MAELxC,KAAK,EAAEwC;IAFF,CAAP;EAID,CALoB,CAArB;EAMA,MAAMmJ,cAAc,GAAG,EAAvB;;EACA,IAAIzC,EAAE,IAAI,CAAChF,SAAX,EAAsB;IACpByH,cAAc,CAAC7D,IAAf,CAAoB;MAClB8B,IAAI,EAAElD,qBAAqB,CAAC/F,MAAD,EAAS,IAAT,CADT;MAElBX,KAAK,EAAE;IAFW,CAApB;EAID;;EACD,IAAImJ,EAAE,IAAI,CAACjF,SAAX,EAAsB;IACpByH,cAAc,CAAC7D,IAAf,CAAoB;MAClB8B,IAAI,EAAElD,qBAAqB,CAAC/F,MAAD,EAAS,IAAT,CADT;MAElBX,KAAK,EAAE;IAFW,CAApB;EAID;;EACD,OAAO;IACL4L,WAAW,EAAEF,YADR;IAELG,SAAS,EAAEJ,UAFN;IAGLK,aAAa,EAAEH;EAHV,CAAP;AAKD,CAjCD;;AAmCA,MAAMI,eAAe,GACrB;AACA,oIAFA,C,CAGA;;AACA,MAAMC,WAAW,GAAG,qFAApB;AACA;AACA;AACA;AACA;;AACA,MAAMC,uBAAuB,GAAIC,KAAD,IAAW;EACzC,IAAIA,KAAK,KAAKrL,SAAd,EAAyB;IACvB;EACD;;EACD,IAAIsL,cAAc,GAAGD,KAArB;;EACA,IAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;IAC7B;IACA;IACAC,cAAc,GAAGD,KAAK,CAACE,OAAN,CAAc,WAAd,EAA2B,EAA3B,EAA+BC,KAA/B,CAAqC,GAArC,CAAjB;EACD;;EACD,IAAIC,MAAJ;;EACA,IAAIlM,KAAK,CAACC,OAAN,CAAc8L,cAAd,CAAJ,EAAmC;IACjC;IACAG,MAAM,GAAGH,cAAc,CAAC7J,GAAf,CAAoBiK,GAAD,IAASC,QAAQ,CAACD,GAAD,EAAM,EAAN,CAApC,EAA+C1D,MAA/C,CAAsD4D,QAAtD,CAAT;EACD,CAHD,MAIK;IACHH,MAAM,GAAG,CAACH,cAAD,CAAT;EACD;;EACD,OAAOG,MAAP;AACD,CAnBD;AAoBA;AACA;AACA;AACA;AACA;;;AACA,MAAMI,uBAAuB,GAAIC,EAAD,IAAQ;EACtC,OAAO;IACLjN,KAAK,EAAE8M,QAAQ,CAACG,EAAE,CAACC,YAAH,CAAgB,YAAhB,CAAD,EAAgC,EAAhC,CADV;IAELjN,GAAG,EAAE6M,QAAQ,CAACG,EAAE,CAACC,YAAH,CAAgB,UAAhB,CAAD,EAA8B,EAA9B,CAFR;IAGLhN,IAAI,EAAE4M,QAAQ,CAACG,EAAE,CAACC,YAAH,CAAgB,WAAhB,CAAD,EAA+B,EAA/B,CAHT;IAIL7J,SAAS,EAAEyJ,QAAQ,CAACG,EAAE,CAACC,YAAH,CAAgB,kBAAhB,CAAD,EAAsC,EAAtC;EAJd,CAAP;AAMD,CAPD;;AAQA,SAASC,SAAT,CAAmBvM,GAAnB,EAAwB;EACtB,IAAIF,KAAK,CAACC,OAAN,CAAcC,GAAd,CAAJ,EAAwB;IACtB,OAAOA,GAAG,CAACgC,GAAJ,CAASwK,MAAD,IAAYD,SAAS,CAACC,MAAD,CAA7B,CAAP;EACD,CAHqB,CAItB;EACA;;;EACA,IAAIC,KAAK,GAAG,IAAZ;;EACA,IAAIzM,GAAG,IAAI,IAAP,IAAeA,GAAG,KAAK,EAA3B,EAA+B;IAC7B;IACAyM,KAAK,GAAGf,WAAW,CAACgB,IAAZ,CAAiB1M,GAAjB,CAAR;;IACA,IAAIyM,KAAJ,EAAW;MACT;MACAA,KAAK,CAACE,OAAN,CAAcpM,SAAd,EAAyBA,SAAzB;MACAkM,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAAC,CAAD,CAAL,GAAWlM,SAAtB;IACD,CAJD,MAKK;MACH;MACAkM,KAAK,GAAGhB,eAAe,CAACiB,IAAhB,CAAqB1M,GAArB,CAAR;IACD;EACF;;EACD,IAAIyM,KAAK,KAAK,IAAd,EAAoB;IAClB;IACA,OAAOlM,SAAP;EACD,CAvBqB,CAwBtB;;;EACA,KAAK,IAAI6G,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,EAAxB,EAA4B;IAC1BqF,KAAK,CAACrF,CAAD,CAAL,GAAWqF,KAAK,CAACrF,CAAD,CAAL,KAAa7G,SAAb,GAAyB2L,QAAQ,CAACO,KAAK,CAACrF,CAAD,CAAN,EAAW,EAAX,CAAjC,GAAkD7G,SAA7D;EACD;;EACD,IAAI4B,QAAQ,GAAG,CAAf;;EACA,IAAIsK,KAAK,CAAC,CAAD,CAAL,IAAYA,KAAK,CAAC,EAAD,CAArB,EAA2B;IACzB;IACAtK,QAAQ,GAAG+J,QAAQ,CAACO,KAAK,CAAC,EAAD,CAAN,EAAY,EAAZ,CAAR,GAA0B,EAArC;;IACA,IAAIA,KAAK,CAAC,EAAD,CAAT,EAAe;MACb;MACAtK,QAAQ,IAAI+J,QAAQ,CAACO,KAAK,CAAC,EAAD,CAAN,EAAY,EAAZ,CAApB;IACD;;IACD,IAAIA,KAAK,CAAC,CAAD,CAAL,KAAa,GAAjB,EAAsB;MACpB;MACAtK,QAAQ,IAAI,CAAC,CAAb;IACD;EACF,CAxCqB,CAyCtB;;;EACA,OAAO;IACL7C,IAAI,EAAEmN,KAAK,CAAC,CAAD,CADN;IAELrN,KAAK,EAAEqN,KAAK,CAAC,CAAD,CAFP;IAGLpN,GAAG,EAAEoN,KAAK,CAAC,CAAD,CAHL;IAIL9L,IAAI,EAAE8L,KAAK,CAAC,CAAD,CAJN;IAKLvK,MAAM,EAAEuK,KAAK,CAAC,CAAD,CALR;IAMLtK;EANK,CAAP;AAQD;;AACD,MAAMyK,SAAS,GAAG,CAAChC,SAAD,EAAY7C,QAAZ,EAAsBC,QAAtB,KAAmC;EACnD,IAAID,QAAQ,IAAIxI,QAAQ,CAACqL,SAAD,EAAY7C,QAAZ,CAAxB,EAA+C;IAC7C,OAAOA,QAAP;EACD,CAFD,MAGK,IAAIC,QAAQ,IAAIxI,OAAO,CAACoL,SAAD,EAAY5C,QAAZ,CAAvB,EAA8C;IACjD,OAAOA,QAAP;EACD;;EACD,OAAO4C,SAAP;AACD,CARD;AASA;AACA;AACA;AACA;AACA;;;AACA,MAAMiC,SAAS,GAAIlM,IAAD,IAAU;EAC1B,OAAOA,IAAI,IAAI,EAAR,GAAa,IAAb,GAAoB,IAA3B;AACD,CAFD;;AAIA,SAAS0E,eAAe,IAAIyH,CAA5B,EAA+BrF,cAAc,IAAIsF,CAAjD,EAAoDjE,cAAc,IAAIkE,CAAtE,EAAyE5M,QAAQ,IAAI6M,CAArF,EAAwF5I,gBAAgB,IAAI6I,CAA5G,EAA+G9H,cAAc,IAAI+H,CAAjI,EAAoI5G,WAAW,IAAI6G,CAAnJ,EAAsJ1J,WAAW,IAAI2J,CAArK,EAAwK5J,eAAe,IAAI6J,CAA3L,EAA8LV,SAAS,IAAIW,CAA3M,EAA8MV,SAAS,IAAIW,CAA3N,EAA8N3J,qBAAqB,IAAI4J,CAAvP,EAA0PlI,oBAAoB,IAAImI,CAAlR,EAAqRpI,kBAAkB,IAAIqI,CAA3S,EAA8SnO,OAAO,IAAIoO,CAAzT,EAA4T3O,SAAS,IAAI4O,CAAzU,EAA4UzK,gBAAgB,IAAI0K,CAAhW,EAAmWxK,YAAY,IAAIyK,CAAnX,EAAsXtH,QAAQ,IAAIuH,CAAlY,EAAqY5B,uBAAuB,IAAI6B,CAAha,EAAmajJ,oBAAoB,IAAIkJ,CAA3b,EAA8bvL,YAAY,IAAIwL,CAA9c,EAAid5O,QAAQ,IAAI6H,CAA7d,EAAge7E,cAAc,IAAI6L,CAAlf,EAAqftL,cAAc,IAAIuL,CAAvgB,EAA0gBxL,UAAU,IAAIyL,CAAxhB,EAA2hBvL,eAAe,IAAIwL,CAA9iB,EAAijBvL,WAAW,IAAIwL,CAAhkB,EAAmkB7C,uBAAuB,IAAI8C,CAA9lB,EAAimBlC,SAAS,IAAIxN,CAA9mB,EAAinB+C,gBAAgB,IAAI4M,CAAroB,EAAwoBpE,yBAAyB,IAAIqE,CAArqB,EAAwqB5F,kBAAkB,IAAI6F,CAA9rB,EAAisBnF,gBAAgB,IAAIoF,CAArtB,EAAwtB7E,iBAAiB,IAAI8E,CAA7uB,EAAgvBxN,kBAAkB,IAAIyN,CAAtwB,EAAywBtP,sBAAsB,IAAIuP,CAAnyB,EAAsyBhE,kBAAkB,IAAIiE,CAA5zB,EAA+zBzN,oBAAoB,IAAI0N,CAAv1B,EAA01BrI,aAAa,IAAIsI,CAA32B"},"metadata":{},"sourceType":"module"}